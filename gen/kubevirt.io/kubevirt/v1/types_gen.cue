// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f crds.yaml

package v1

import "strings"

// KubeVirt represents the object deploying all KubeVirt resources
#KubeVirt: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "kubevirt.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "KubeVirt"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}
	spec!: #KubeVirtSpec
}
#KubeVirtSpec: {
	certificateRotateStrategy?: {
		selfSigned?: {
			// CA configuration
			// CA certs are kept in the CA bundle as long as they are valid
			ca?: {
				// The requested 'duration' (i.e. lifetime) of the Certificate.
				duration?: string

				// The amount of time before the currently issued certificate's
				// "notAfter"
				// time that we will begin to attempt to renew the certificate.
				renewBefore?: string
			}

			// Deprecated. Use CA.Duration and CA.RenewBefore instead
			caOverlapInterval?: string

			// Deprecated. Use CA.Duration instead
			caRotateInterval?: string

			// Deprecated. Use Server.Duration instead
			certRotateInterval?: string

			// Server configuration
			// Certs are rotated and discarded
			server?: {
				// The requested 'duration' (i.e. lifetime) of the Certificate.
				duration?: string

				// The amount of time before the currently issued certificate's
				// "notAfter"
				// time that we will begin to attempt to renew the certificate.
				renewBefore?: string
			}
		}
	}

	// holds kubevirt configurations.
	// same as the virt-configMap
	configuration?: {
		// AdditionalGuestMemoryOverheadRatio can be used to increase the
		// virtualization infrastructure
		// overhead. This is useful, since the calculation of this
		// overhead is not accurate and cannot
		// be entirely known in advance. The ratio that is being set
		// determines by which factor to increase
		// the overhead calculated by Kubevirt. A higher ratio means that
		// the VMs would be less compromised
		// by node pressures, but would mean that fewer VMs could be
		// scheduled to a node.
		// If not set, the default is 1.
		additionalGuestMemoryOverheadRatio?: string
		apiConfiguration?: {
			restClient?: {
				rateLimiter?: {
					tokenBucketRateLimiter?: {
						// Maximum burst for throttle.
						// If it's zero, the component default will be used
						burst: int

						// QPS indicates the maximum QPS to the apiserver from this
						// client.
						// If it's zero, the component default will be used
						qps: number
					}
				}
			}
		}
		architectureConfiguration?: {
			amd64?: {
				emulatedMachines?: [...string]
				machineType?: string
				ovmfPath?:    string
			}
			arm64?: {
				emulatedMachines?: [...string]
				machineType?: string
				ovmfPath?:    string
			}
			defaultArchitecture?: string
			ppc64le?: {
				emulatedMachines?: [...string]
				machineType?: string
				ovmfPath?:    string
			}
		}

		// When set, AutoCPULimitNamespaceLabelSelector will set a CPU
		// limit on virt-launcher for VMIs running inside
		// namespaces that match the label selector.
		// The CPU limit will equal the number of requested vCPUs.
		// This setting does not apply to VMIs with dedicated CPUs.
		autoCPULimitNamespaceLabelSelector?: {
			// matchExpressions is a list of label selector requirements. The
			// requirements are ANDed.
			matchExpressions?: [...{
				// key is the label key that the selector applies to.
				key: string

				// operator represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists and DoesNotExist.
				operator: string

				// values is an array of string values. If the operator is In or
				// NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. This array is replaced during a
				// strategic
				// merge patch.
				values?: [...string]
			}]

			// matchLabels is a map of {key,value} pairs. A single {key,value}
			// in the matchLabels
			// map is equivalent to an element of matchExpressions, whose key
			// field is "key", the
			// operator is "In", and the values array contains only "value".
			// The requirements are ANDed.
			matchLabels?: {
				[string]: string
			}
		}
		controllerConfiguration?: {
			restClient?: {
				rateLimiter?: {
					tokenBucketRateLimiter?: {
						// Maximum burst for throttle.
						// If it's zero, the component default will be used
						burst: int

						// QPS indicates the maximum QPS to the apiserver from this
						// client.
						// If it's zero, the component default will be used
						qps: number
					}
				}
			}
		}
		cpuModel?: string
		cpuRequest?: (int | string) & {
			=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
		}
		defaultRuntimeClass?: string

		// DeveloperConfiguration holds developer options
		developerConfiguration?: {
			// For each requested virtual CPU, CPUAllocationRatio defines how
			// much physical CPU to request per VMI
			// from the hosting node. The value is in fraction of a CPU thread
			// (or core on non-hyperthreaded nodes).
			// For example, a value of 1 means 1 physical CPU thread per VMI
			// CPU thread.
			// A value of 100 would be 1% of a physical thread allocated for
			// each requested VMI thread.
			// This option has no effect on VMIs that request dedicated CPUs.
			// More information at:
			// https://kubevirt.io/user-guide/operations/node_overcommit/#node-cpu-allocation-ratio
			// Defaults to 10
			cpuAllocationRatio?: int
			diskVerification?: {
				memoryLimit: (int | string) & {
					=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}

			// FeatureGates is the list of experimental features to enable.
			// Defaults to none
			featureGates?: [...string]

			// LogVerbosity sets log verbosity level of various components
			logVerbosity?: {
				// NodeVerbosity represents a map of nodes with a specific
				// verbosity level
				nodeVerbosity?: {
					[string]: int
				}
				virtAPI?:        int
				virtController?: int
				virtHandler?:    int
				virtLauncher?:   int
				virtOperator?:   int
			}

			// MemoryOvercommit is the percentage of memory we want to give
			// VMIs compared to the amount
			// given to its parent pod (virt-launcher). For example, a value
			// of 102 means the VMI will
			// "see" 2% more memory than its parent pod. Values under 100 are
			// effectively "undercommits".
			// Overcommits can lead to memory exhaustion, which in turn can
			// lead to crashes. Use carefully.
			// Defaults to 100
			memoryOvercommit?: int

			// Allow overriding the automatically determined minimum TSC
			// frequency of the cluster
			// and fixate the minimum to this frequency.
			minimumClusterTSCFrequency?: int

			// MinimumReservePVCBytes is the amount of space, in bytes, to
			// leave unused on disks.
			// Defaults to 131072 (128KiB)
			minimumReservePVCBytes?: int

			// NodeSelectors allows restricting VMI creation to nodes that
			// match a set of labels.
			// Defaults to none
			nodeSelectors?: {
				[string]: string
			}

			// LessPVCSpaceToleration determines how much smaller, in
			// percentage, disk PVCs are
			// allowed to be compared to the requested size (to account for
			// various overheads).
			// Defaults to 10
			pvcTolerateLessSpaceUpToPercent?: int

			// UseEmulation can be set to true to allow fallback to software
			// emulation
			// in case hardware-assisted emulation is not available. Defaults
			// to false
			useEmulation?: bool
		}

		// Deprecated. Use architectureConfiguration instead.
		emulatedMachines?: [...string]

		// EvictionStrategy defines at the cluster level if the
		// VirtualMachineInstance should be
		// migrated instead of shut-off in case of a node drain. If the
		// VirtualMachineInstance specific
		// field is set it overrides the cluster level one.
		evictionStrategy?: string
		handlerConfiguration?: {
			restClient?: {
				rateLimiter?: {
					tokenBucketRateLimiter?: {
						// Maximum burst for throttle.
						// If it's zero, the component default will be used
						burst: int

						// QPS indicates the maximum QPS to the apiserver from this
						// client.
						// If it's zero, the component default will be used
						qps: number
					}
				}
			}
		}

		// PullPolicy describes a policy for if/when to pull a container
		// image
		imagePullPolicy?: string
		ksmConfiguration?: {
			// NodeLabelSelector is a selector that filters in which nodes the
			// KSM will be enabled.
			// Empty NodeLabelSelector will enable ksm for every node.
			nodeLabelSelector?: {
				// matchExpressions is a list of label selector requirements. The
				// requirements are ANDed.
				matchExpressions?: [...{
					// key is the label key that the selector applies to.
					key: string

					// operator represents a key's relationship to a set of values.
					// Valid operators are In, NotIn, Exists and DoesNotExist.
					operator: string

					// values is an array of string values. If the operator is In or
					// NotIn,
					// the values array must be non-empty. If the operator is Exists
					// or DoesNotExist,
					// the values array must be empty. This array is replaced during a
					// strategic
					// merge patch.
					values?: [...string]
				}]

				// matchLabels is a map of {key,value} pairs. A single {key,value}
				// in the matchLabels
				// map is equivalent to an element of matchExpressions, whose key
				// field is "key", the
				// operator is "In", and the values array contains only "value".
				// The requirements are ANDed.
				matchLabels?: {
					[string]: string
				}
			}
		}

		// LiveUpdateConfiguration holds defaults for live update features
		liveUpdateConfiguration?: {
			// MaxCpuSockets holds the maximum amount of sockets that can be
			// hotplugged
			maxCpuSockets?: int

			// MaxGuest defines the maximum amount memory that can be
			// allocated
			// to the guest using hotplug.
			maxGuest?: (int | string) & {
				=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}

			// MaxHotplugRatio is the ratio used to define the max amount
			// of a hotplug resource that can be made available to a VM
			// when the specific Max* setting is not defined (MaxCpuSockets,
			// MaxGuest)
			// Example: VM is configured with 512Mi of guest memory, if
			// MaxGuest is not
			// defined and MaxHotplugRatio is 2 then MaxGuest = 1Gi
			// defaults to 4
			maxHotplugRatio?: int
		}

		// Deprecated. Use architectureConfiguration instead.
		machineType?: string

		// MediatedDevicesConfiguration holds information about MDEV types
		// to be defined, if available
		mediatedDevicesConfiguration?: {
			mediatedDeviceTypes?: [...string]

			// Deprecated. Use mediatedDeviceTypes instead.
			mediatedDevicesTypes?: [...string]
			nodeMediatedDeviceTypes?: [...{
				mediatedDeviceTypes?: [...string]

				// Deprecated. Use mediatedDeviceTypes instead.
				mediatedDevicesTypes?: [...string]

				// NodeSelector is a selector which must be true for the vmi to
				// fit on a node.
				// Selector which must match a node's labels for the vmi to be
				// scheduled on that node.
				// More info:
				// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
				nodeSelector: {
					[string]: string
				}
			}]
		}
		memBalloonStatsPeriod?: int

		// MigrationConfiguration holds migration options.
		// Can be overridden for specific groups of VMs though migration
		// policies.
		// Visit
		// https://kubevirt.io/user-guide/operations/migration_policies/
		// for more information.
		migrations?: {
			// AllowAutoConverge allows the platform to compromise
			// performance/availability of VMIs to
			// guarantee successful VMI live migrations. Defaults to false
			allowAutoConverge?: bool

			// AllowPostCopy enables post-copy live migrations. Such
			// migrations allow even the busiest VMIs
			// to successfully live-migrate. However, events like a network
			// failure can cause a VMI crash.
			// If set to true, migrations will still start in pre-copy, but
			// switch to post-copy when
			// CompletionTimeoutPerGiB triggers. Defaults to false
			allowPostCopy?: bool

			// BandwidthPerMigration limits the amount of network bandwidth
			// live migrations are allowed to use.
			// The value is in quantity per second. Defaults to 0 (no limit)
			bandwidthPerMigration?: (int | string) & {
				=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}

			// CompletionTimeoutPerGiB is the maximum number of seconds per
			// GiB a migration is allowed to take.
			// If a live-migration takes longer to migrate than this value
			// multiplied by the size of the VMI,
			// the migration will be cancelled, unless AllowPostCopy is true.
			// Defaults to 800
			completionTimeoutPerGiB?: int

			// When set to true, DisableTLS will disable the additional layer
			// of live migration encryption
			// provided by KubeVirt. This is usually a bad idea. Defaults to
			// false
			disableTLS?: bool

			// By default, the SELinux level of target virt-launcher pods is
			// forced to the level of the source virt-launcher.
			// When set to true, MatchSELinuxLevelOnMigration lets the CRI
			// auto-assign a random level to the target.
			// That will ensure the target virt-launcher doesn't share
			// categories with another pod on the node.
			// However, migrations will fail when using RWX volumes that don't
			// automatically deal with SELinux levels.
			matchSELinuxLevelOnMigration?: bool

			// Network is the name of the CNI network to use for live
			// migrations. By default, migrations go
			// through the pod network.
			network?: string

			// NodeDrainTaintKey defines the taint key that indicates a node
			// should be drained.
			// Note: this option relies on the deprecated node taint feature.
			// Default: kubevirt.io/drain
			nodeDrainTaintKey?: string

			// ParallelMigrationsPerCluster is the total number of concurrent
			// live migrations
			// allowed cluster-wide. Defaults to 5
			parallelMigrationsPerCluster?: int

			// ParallelOutboundMigrationsPerNode is the maximum number of
			// concurrent outgoing live migrations
			// allowed per node. Defaults to 2
			parallelOutboundMigrationsPerNode?: int

			// ProgressTimeout is the maximum number of seconds a live
			// migration is allowed to make no progress.
			// Hitting this timeout means a migration transferred 0 data for
			// that many seconds. The migration is
			// then considered stuck and therefore cancelled. Defaults to 150
			progressTimeout?: int

			// UnsafeMigrationOverride allows live migrations to occur even if
			// the compatibility check
			// indicates the migration will be unsafe to the guest. Defaults
			// to false
			unsafeMigrationOverride?: bool
		}
		minCPUModel?: string

		// NetworkConfiguration holds network options
		network?: {
			binding?: {
				[string]: {
					// ComputeResourceOverhead specifies the resource overhead that
					// should be added to the compute container when using the
					// binding.
					// version: v1alphav1
					computeResourceOverhead?: {
						// Claims lists the names of resources, defined in
						// spec.resourceClaims,
						// that are used by this container.
						//
						//
						// This is an alpha field and requires enabling the
						// DynamicResourceAllocation feature gate.
						//
						//
						// This field is immutable. It can only be set for containers.
						claims?: [...{
							// Name must match the name of one entry in
							// pod.spec.resourceClaims of
							// the Pod where this field is used. It makes that resource
							// available
							// inside a container.
							name: string
						}]

						// Limits describes the maximum amount of compute resources
						// allowed.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Requests describes the minimum amount of compute resources
						// required.
						// If Requests is omitted for a container, it defaults to Limits
						// if that is explicitly specified,
						// otherwise to an implementation-defined value. Requests cannot
						// exceed Limits.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}
					}

					// DomainAttachmentType is a standard domain network attachment
					// method kubevirt supports.
					// Supported values: "tap".
					// The standard domain attachment can be used instead or in
					// addition to the sidecarImage.
					// version: 1alphav1
					domainAttachmentType?: string

					// DownwardAPI specifies what kind of data should be exposed to
					// the binding plugin sidecar.
					// Supported values: "device-info"
					// version: v1alphav1
					downwardAPI?: string
					migration?: {
						// Method defines a pre-defined migration methodology
						// version: 1alphav1
						method?: string
					}

					// NetworkAttachmentDefinition references to a
					// NetworkAttachmentDefinition CR object.
					// Format: <name>, <namespace>/<name>.
					// If namespace is not specified, VMI namespace is assumed.
					// version: 1alphav1
					networkAttachmentDefinition?: string

					// SidecarImage references a container image that runs in the
					// virt-launcher pod.
					// The sidecar handles (libvirt) domain configuration and optional
					// services.
					// version: 1alphav1
					sidecarImage?: string
				}
			}
			defaultNetworkInterface?:           string
			permitBridgeInterfaceOnPodNetwork?: bool

			// DeprecatedPermitSlirpInterface is an alias for the deprecated
			// PermitSlirpInterface.
			// Deprecated: Removed in v1.3.
			permitSlirpInterface?: bool
		}
		obsoleteCPUModels?: {
			[string]: bool
		}

		// Deprecated. Use architectureConfiguration instead.
		ovmfPath?: string

		// PermittedHostDevices holds information about devices allowed
		// for passthrough
		permittedHostDevices?: {
			mediatedDevices?: [...{
				externalResourceProvider?: bool
				mdevNameSelector:          string
				resourceName:              string
			}]
			pciHostDevices?: [...{
				// If true, KubeVirt will leave the allocation and monitoring to
				// an
				// external device plugin
				externalResourceProvider?: bool

				// The vendor_id:product_id tuple of the PCI device
				pciVendorSelector: string

				// The name of the resource that is representing the device.
				// Exposed by
				// a device plugin and requested by VMs. Typically of the form
				// vendor.com/product_name
				resourceName: string
			}]
			usb?: [...{
				// If true, KubeVirt will leave the allocation and monitoring to
				// an
				// external device plugin
				externalResourceProvider?: bool

				// Identifies the list of USB host devices.
				// e.g: kubevirt.io/storage, kubevirt.io/bootable-usb, etc
				resourceName: string
				selectors?: [...{
					product: string
					vendor:  string
				}]
			}]
		}
		seccompConfiguration?: {
			virtualMachineInstanceProfile?: {
				// CustomProfile allows to request arbitrary profile for
				// virt-launcher
				customProfile?: {
					localhostProfile?:      string
					runtimeDefaultProfile?: bool
				}
			}
		}
		selinuxLauncherType?: string
		smbios?: {
			family?:       string
			manufacturer?: string
			product?:      string
			sku?:          string
			version?:      string
		}

		// SupportContainerResources specifies the resource requirements
		// for various types of supporting containers such as container
		// disks/virtiofs/sidecars and hotplug attachment pods. If
		// omitted a sensible default will be supplied.
		supportContainerResources?: [...{
			// ResourceRequirements describes the compute resource
			// requirements.
			resources: {
				// Claims lists the names of resources, defined in
				// spec.resourceClaims,
				// that are used by this container.
				//
				//
				// This is an alpha field and requires enabling the
				// DynamicResourceAllocation feature gate.
				//
				//
				// This field is immutable. It can only be set for containers.
				claims?: [...{
					// Name must match the name of one entry in
					// pod.spec.resourceClaims of
					// the Pod where this field is used. It makes that resource
					// available
					// inside a container.
					name: string
				}]

				// Limits describes the maximum amount of compute resources
				// allowed.
				// More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required.
				// If Requests is omitted for a container, it defaults to Limits
				// if that is explicitly specified,
				// otherwise to an implementation-defined value. Requests cannot
				// exceed Limits.
				// More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}
			type: string
		}]

		// deprecated
		supportedGuestAgentVersions?: [...string]

		// TLSConfiguration holds TLS options
		tlsConfiguration?: {
			ciphers?: [...string]

			// MinTLSVersion is a way to specify the minimum protocol version
			// that is acceptable for TLS connections.
			// Protocol versions are based on the following most common TLS
			// configurations:
			//
			//
			// https://ssl-config.mozilla.org/
			//
			//
			// Note that SSLv3.0 is not a supported protocol version due to
			// well known
			// vulnerabilities such as POODLE:
			// https://en.wikipedia.org/wiki/POODLE
			minTLSVersion?: "VersionTLS10" | "VersionTLS11" | "VersionTLS12" | "VersionTLS13"
		}
		virtualMachineInstancesPerNode?: int

		// VirtualMachineOptions holds the cluster level information
		// regarding the virtual machine.
		virtualMachineOptions?: {
			// DisableFreePageReporting disable the free page reporting of
			// memory balloon device
			// https://libvirt.org/formatdomain.html#memory-balloon-device.
			// This will have effect only if AutoattachMemBalloon is not false
			// and the vmi is not
			// requesting any high performance feature
			// (dedicatedCPU/realtime/hugePages), in which free page
			// reporting is always disabled.
			disableFreePageReporting?: {}

			// DisableSerialConsoleLog disables logging the auto-attached
			// default serial console.
			// If not set, serial console logs will be written to a file and
			// then streamed from a container named 'guest-console-log'.
			// The value can be individually overridden for each VM, not
			// relevant if AutoattachSerialConsole is disabled.
			disableSerialConsoleLog?: {}
		}

		// VMRolloutStrategy defines how changes to a VM object propagate
		// to its VMI
		vmRolloutStrategy?: null | "Stage" | "LiveUpdate"

		// VMStateStorageClass is the name of the storage class to use for
		// the PVCs created to preserve VM state, like TPM.
		// The storage class must support RWX in filesystem mode.
		vmStateStorageClass?: string
		webhookConfiguration?: {
			restClient?: {
				rateLimiter?: {
					tokenBucketRateLimiter?: {
						// Maximum burst for throttle.
						// If it's zero, the component default will be used
						burst: int

						// QPS indicates the maximum QPS to the apiserver from this
						// client.
						// If it's zero, the component default will be used
						qps: number
					}
				}
			}
		}
	}
	customizeComponents?: {
		// Configure the value used for deployment and daemonset resources
		flags?: {
			api?: {
				[string]: string
			}
			controller?: {
				[string]: string
			}
			handler?: {
				[string]: string
			}
		}
		patches?: [...{
			patch:        string
			resourceName: strings.MinRunes(1)
			resourceType: strings.MinRunes(1)
			type:         string
		}]
	}

	// The ImagePullPolicy to use.
	imagePullPolicy?: string

	// The imagePullSecrets to pull the container images from
	// Defaults to none
	imagePullSecrets?: [...{
		// Name of the referent.
		// More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		// TODO: Add other useful fields. apiVersion, kind, uid?
		name?: string
	}]

	// The image registry to pull the container images from
	// Defaults to the same registry the operator's container image is
	// pulled from.
	imageRegistry?: string

	// The image tag to use for the continer images installed.
	// Defaults to the same tag as the operator's container image.
	imageTag?: string

	// selectors and tolerations that should apply to KubeVirt
	// infrastructure components
	infra?: {
		// nodePlacement describes scheduling configuration for specific
		// KubeVirt components
		nodePlacement?: {
			// affinity enables pod affinity/anti-affinity placement expanding
			// the types of constraints
			// that can be expressed with nodeSelector.
			// affinity is going to be applied to the relevant kind of pods in
			// parallel with nodeSelector
			// See
			// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
			affinity?: {
				// Describes node affinity scheduling rules for the pod.
				nodeAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy
					// the affinity expressions specified by this field, but it may
					// choose
					// a node that violates one or more of the expressions. The node
					// that is
					// most preferred is the one with the greatest sum of weights,
					// i.e.
					// for each node that meets all of the scheduling requirements
					// (resource
					// request, requiredDuringScheduling affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding
					// "weight" to the sum if the node matches the corresponding
					// matchExpressions; the
					// node(s) with the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// A node selector term, associated with the corresponding weight.
						preference: {
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]
						}

						// Weight associated with matching the corresponding
						// nodeSelectorTerm, in the range 1-100.
						weight: int
					}]
					requiredDuringSchedulingIgnoredDuringExecution?: {
						// Required. A list of node selector terms. The terms are ORed.
						nodeSelectorTerms: [...{
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]
						}]
					}
				}

				// Describes pod affinity scheduling rules (e.g. co-locate this
				// pod in the same node, zone, etc. as some other pod(s)).
				podAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy
					// the affinity expressions specified by this field, but it may
					// choose
					// a node that violates one or more of the expressions. The node
					// that is
					// most preferred is the one with the greatest sum of weights,
					// i.e.
					// for each node that meets all of the scheduling requirements
					// (resource
					// request, requiredDuringScheduling affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding
					// "weight" to the sum if the node has pods which matches the
					// corresponding podAffinityTerm; the
					// node(s) with the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							// If it's null, this PodAffinityTerm matches with no Pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select which pods
							// will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key in (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both matchLabelKeys and
							// labelSelector.
							// Also, matchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							matchLabelKeys?: [...string]

							// MismatchLabelKeys is a set of pod label keys to select which
							// pods will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key notin (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both mismatchLabelKeys
							// and labelSelector.
							// Also, mismatchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							mismatchLabelKeys?: [...string]

							// A label query over the set of namespaces that the term applies
							// to.
							// The term is applied to the union of the namespaces selected by
							// this field
							// and the ones listed in the namespaces field.
							// null selector and null or empty namespaces list means "this
							// pod's namespace".
							// An empty selector ({}) matches all namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to.
							// The term is applied to the union of the namespaces listed in
							// this field
							// and the ones selected by namespaceSelector.
							// null or empty namespaces list and null namespaceSelector means
							// "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching
							// the labelSelector in the specified namespaces, where co-located
							// is defined as running on a node
							// whose value of the label with key topologyKey matches that of
							// any node on which any of the
							// selected pods is running.
							// Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm,
						// in the range 1-100.
						weight: int
					}]

					// If the affinity requirements specified by this field are not
					// met at
					// scheduling time, the pod will not be scheduled onto the node.
					// If the affinity requirements specified by this field cease to
					// be met
					// at some point during pod execution (e.g. due to a pod label
					// update), the
					// system may or may not try to eventually evict the pod from its
					// node.
					// When there are multiple elements, the lists of nodes
					// corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						// If it's null, this PodAffinityTerm matches with no Pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select which pods
						// will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key in (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both matchLabelKeys and
						// labelSelector.
						// Also, matchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						matchLabelKeys?: [...string]

						// MismatchLabelKeys is a set of pod label keys to select which
						// pods will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key notin (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both mismatchLabelKeys
						// and labelSelector.
						// Also, mismatchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						mismatchLabelKeys?: [...string]

						// A label query over the set of namespaces that the term applies
						// to.
						// The term is applied to the union of the namespaces selected by
						// this field
						// and the ones listed in the namespaces field.
						// null selector and null or empty namespaces list means "this
						// pod's namespace".
						// An empty selector ({}) matches all namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to.
						// The term is applied to the union of the namespaces listed in
						// this field
						// and the ones selected by namespaceSelector.
						// null or empty namespaces list and null namespaceSelector means
						// "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching
						// the labelSelector in the specified namespaces, where co-located
						// is defined as running on a node
						// whose value of the label with key topologyKey matches that of
						// any node on which any of the
						// selected pods is running.
						// Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}

				// Describes pod anti-affinity scheduling rules (e.g. avoid
				// putting this pod in the same node, zone, etc. as some other
				// pod(s)).
				podAntiAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy
					// the anti-affinity expressions specified by this field, but it
					// may choose
					// a node that violates one or more of the expressions. The node
					// that is
					// most preferred is the one with the greatest sum of weights,
					// i.e.
					// for each node that meets all of the scheduling requirements
					// (resource
					// request, requiredDuringScheduling anti-affinity expressions,
					// etc.),
					// compute a sum by iterating through the elements of this field
					// and adding
					// "weight" to the sum if the node has pods which matches the
					// corresponding podAffinityTerm; the
					// node(s) with the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							// If it's null, this PodAffinityTerm matches with no Pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select which pods
							// will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key in (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both matchLabelKeys and
							// labelSelector.
							// Also, matchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							matchLabelKeys?: [...string]

							// MismatchLabelKeys is a set of pod label keys to select which
							// pods will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key notin (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both mismatchLabelKeys
							// and labelSelector.
							// Also, mismatchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							mismatchLabelKeys?: [...string]

							// A label query over the set of namespaces that the term applies
							// to.
							// The term is applied to the union of the namespaces selected by
							// this field
							// and the ones listed in the namespaces field.
							// null selector and null or empty namespaces list means "this
							// pod's namespace".
							// An empty selector ({}) matches all namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to.
							// The term is applied to the union of the namespaces listed in
							// this field
							// and the ones selected by namespaceSelector.
							// null or empty namespaces list and null namespaceSelector means
							// "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching
							// the labelSelector in the specified namespaces, where co-located
							// is defined as running on a node
							// whose value of the label with key topologyKey matches that of
							// any node on which any of the
							// selected pods is running.
							// Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm,
						// in the range 1-100.
						weight: int
					}]

					// If the anti-affinity requirements specified by this field are
					// not met at
					// scheduling time, the pod will not be scheduled onto the node.
					// If the anti-affinity requirements specified by this field cease
					// to be met
					// at some point during pod execution (e.g. due to a pod label
					// update), the
					// system may or may not try to eventually evict the pod from its
					// node.
					// When there are multiple elements, the lists of nodes
					// corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						// If it's null, this PodAffinityTerm matches with no Pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select which pods
						// will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key in (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both matchLabelKeys and
						// labelSelector.
						// Also, matchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						matchLabelKeys?: [...string]

						// MismatchLabelKeys is a set of pod label keys to select which
						// pods will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key notin (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both mismatchLabelKeys
						// and labelSelector.
						// Also, mismatchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						mismatchLabelKeys?: [...string]

						// A label query over the set of namespaces that the term applies
						// to.
						// The term is applied to the union of the namespaces selected by
						// this field
						// and the ones listed in the namespaces field.
						// null selector and null or empty namespaces list means "this
						// pod's namespace".
						// An empty selector ({}) matches all namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to.
						// The term is applied to the union of the namespaces listed in
						// this field
						// and the ones selected by namespaceSelector.
						// null or empty namespaces list and null namespaceSelector means
						// "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching
						// the labelSelector in the specified namespaces, where co-located
						// is defined as running on a node
						// whose value of the label with key topologyKey matches that of
						// any node on which any of the
						// selected pods is running.
						// Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}
			}

			// nodeSelector is the node selector applied to the relevant kind
			// of pods
			// It specifies a map of key-value pairs: for the pod to be
			// eligible to run on a node,
			// the node must have each of the indicated key-value pairs as
			// labels
			// (it can have additional labels as well).
			// See
			// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
			nodeSelector?: {
				[string]: string
			}

			// tolerations is a list of tolerations applied to the relevant
			// kind of pods
			// See
			// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
			// for more info.
			// These are additional tolerations other than default ones.
			tolerations?: [...{
				// Effect indicates the taint effect to match. Empty means match
				// all taint effects.
				// When specified, allowed values are NoSchedule, PreferNoSchedule
				// and NoExecute.
				effect?: string

				// Key is the taint key that the toleration applies to. Empty
				// means match all taint keys.
				// If the key is empty, operator must be Exists; this combination
				// means to match all values and all keys.
				key?: string

				// Operator represents a key's relationship to the value.
				// Valid operators are Exists and Equal. Defaults to Equal.
				// Exists is equivalent to wildcard for value, so that a pod can
				// tolerate all taints of a particular category.
				operator?: string

				// TolerationSeconds represents the period of time the toleration
				// (which must be
				// of effect NoExecute, otherwise this field is ignored) tolerates
				// the taint. By default,
				// it is not set, which means tolerate the taint forever (do not
				// evict). Zero and
				// negative values will be treated as 0 (evict immediately) by the
				// system.
				tolerationSeconds?: int

				// Value is the taint value the toleration matches to.
				// If the operator is Exists, the value should be empty, otherwise
				// just a regular string.
				value?: string
			}]
		}

		// replicas indicates how many replicas should be created for each
		// KubeVirt infrastructure
		// component (like virt-api or virt-controller). Defaults to 2.
		// WARNING: this is an advanced feature that prevents auto-scaling
		// for core kubevirt components. Please use with caution!
		replicas?: int
	}

	// The name of the Prometheus service account that needs
	// read-access to KubeVirt endpoints
	// Defaults to prometheus-k8s
	monitorAccount?: string

	// The namespace Prometheus is deployed in
	// Defaults to openshift-monitor
	monitorNamespace?: string

	// Designate the apps.kubevirt.io/component label for KubeVirt
	// components.
	// Useful if KubeVirt is included as part of a product.
	// If ProductComponent is not specified, the component label
	// default value is kubevirt.
	productComponent?: string

	// Designate the apps.kubevirt.io/part-of label for KubeVirt
	// components.
	// Useful if KubeVirt is included as part of a product.
	// If ProductName is not specified, the part-of label will be
	// omitted.
	productName?: string

	// Designate the apps.kubevirt.io/version label for KubeVirt
	// components.
	// Useful if KubeVirt is included as part of a product.
	// If ProductVersion is not specified, KubeVirt's version will be
	// used.
	productVersion?: string

	// The namespace the service monitor will be deployed
	// When ServiceMonitorNamespace is set, then we'll install the
	// service monitor object in that namespace
	// otherwise we will use the monitoring namespace.
	serviceMonitorNamespace?: string

	// Specifies if kubevirt can be deleted if workloads are still
	// present.
	// This is mainly a precaution to avoid accidental data loss
	uninstallStrategy?: string

	// WorkloadUpdateStrategy defines at the cluster level how to
	// handle
	// automated workload updates
	workloadUpdateStrategy?: {
		// BatchEvictionInterval Represents the interval to wait before
		// issuing the next
		// batch of shutdowns
		//
		//
		// Defaults to 1 minute
		batchEvictionInterval?: string

		// BatchEvictionSize Represents the number of VMIs that can be
		// forced updated per
		// the BatchShutdownInteral interval
		//
		//
		// Defaults to 10
		batchEvictionSize?: int

		// WorkloadUpdateMethods defines the methods that can be used to
		// disrupt workloads
		// during automated workload updates.
		// When multiple methods are present, the least disruptive method
		// takes
		// precedence over more disruptive methods. For example if both
		// LiveMigrate and Shutdown
		// methods are listed, only VMs which are not live migratable will
		// be restarted/shutdown
		//
		//
		// An empty list defaults to no automated workload updating
		workloadUpdateMethods?: [...string]
	}

	// selectors and tolerations that should apply to KubeVirt
	// workloads
	workloads?: {
		// nodePlacement describes scheduling configuration for specific
		// KubeVirt components
		nodePlacement?: {
			// affinity enables pod affinity/anti-affinity placement expanding
			// the types of constraints
			// that can be expressed with nodeSelector.
			// affinity is going to be applied to the relevant kind of pods in
			// parallel with nodeSelector
			// See
			// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
			affinity?: {
				// Describes node affinity scheduling rules for the pod.
				nodeAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy
					// the affinity expressions specified by this field, but it may
					// choose
					// a node that violates one or more of the expressions. The node
					// that is
					// most preferred is the one with the greatest sum of weights,
					// i.e.
					// for each node that meets all of the scheduling requirements
					// (resource
					// request, requiredDuringScheduling affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding
					// "weight" to the sum if the node matches the corresponding
					// matchExpressions; the
					// node(s) with the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// A node selector term, associated with the corresponding weight.
						preference: {
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]
						}

						// Weight associated with matching the corresponding
						// nodeSelectorTerm, in the range 1-100.
						weight: int
					}]
					requiredDuringSchedulingIgnoredDuringExecution?: {
						// Required. A list of node selector terms. The terms are ORed.
						nodeSelectorTerms: [...{
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
								// Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. If the operator is Gt or Lt,
								// the values
								// array must have a single element, which will be interpreted as
								// an integer.
								// This array is replaced during a strategic merge patch.
								values?: [...string]
							}]
						}]
					}
				}

				// Describes pod affinity scheduling rules (e.g. co-locate this
				// pod in the same node, zone, etc. as some other pod(s)).
				podAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy
					// the affinity expressions specified by this field, but it may
					// choose
					// a node that violates one or more of the expressions. The node
					// that is
					// most preferred is the one with the greatest sum of weights,
					// i.e.
					// for each node that meets all of the scheduling requirements
					// (resource
					// request, requiredDuringScheduling affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding
					// "weight" to the sum if the node has pods which matches the
					// corresponding podAffinityTerm; the
					// node(s) with the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							// If it's null, this PodAffinityTerm matches with no Pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select which pods
							// will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key in (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both matchLabelKeys and
							// labelSelector.
							// Also, matchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							matchLabelKeys?: [...string]

							// MismatchLabelKeys is a set of pod label keys to select which
							// pods will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key notin (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both mismatchLabelKeys
							// and labelSelector.
							// Also, mismatchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							mismatchLabelKeys?: [...string]

							// A label query over the set of namespaces that the term applies
							// to.
							// The term is applied to the union of the namespaces selected by
							// this field
							// and the ones listed in the namespaces field.
							// null selector and null or empty namespaces list means "this
							// pod's namespace".
							// An empty selector ({}) matches all namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to.
							// The term is applied to the union of the namespaces listed in
							// this field
							// and the ones selected by namespaceSelector.
							// null or empty namespaces list and null namespaceSelector means
							// "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching
							// the labelSelector in the specified namespaces, where co-located
							// is defined as running on a node
							// whose value of the label with key topologyKey matches that of
							// any node on which any of the
							// selected pods is running.
							// Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm,
						// in the range 1-100.
						weight: int
					}]

					// If the affinity requirements specified by this field are not
					// met at
					// scheduling time, the pod will not be scheduled onto the node.
					// If the affinity requirements specified by this field cease to
					// be met
					// at some point during pod execution (e.g. due to a pod label
					// update), the
					// system may or may not try to eventually evict the pod from its
					// node.
					// When there are multiple elements, the lists of nodes
					// corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						// If it's null, this PodAffinityTerm matches with no Pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select which pods
						// will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key in (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both matchLabelKeys and
						// labelSelector.
						// Also, matchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						matchLabelKeys?: [...string]

						// MismatchLabelKeys is a set of pod label keys to select which
						// pods will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key notin (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both mismatchLabelKeys
						// and labelSelector.
						// Also, mismatchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						mismatchLabelKeys?: [...string]

						// A label query over the set of namespaces that the term applies
						// to.
						// The term is applied to the union of the namespaces selected by
						// this field
						// and the ones listed in the namespaces field.
						// null selector and null or empty namespaces list means "this
						// pod's namespace".
						// An empty selector ({}) matches all namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to.
						// The term is applied to the union of the namespaces listed in
						// this field
						// and the ones selected by namespaceSelector.
						// null or empty namespaces list and null namespaceSelector means
						// "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching
						// the labelSelector in the specified namespaces, where co-located
						// is defined as running on a node
						// whose value of the label with key topologyKey matches that of
						// any node on which any of the
						// selected pods is running.
						// Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}

				// Describes pod anti-affinity scheduling rules (e.g. avoid
				// putting this pod in the same node, zone, etc. as some other
				// pod(s)).
				podAntiAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy
					// the anti-affinity expressions specified by this field, but it
					// may choose
					// a node that violates one or more of the expressions. The node
					// that is
					// most preferred is the one with the greatest sum of weights,
					// i.e.
					// for each node that meets all of the scheduling requirements
					// (resource
					// request, requiredDuringScheduling anti-affinity expressions,
					// etc.),
					// compute a sum by iterating through the elements of this field
					// and adding
					// "weight" to the sum if the node has pods which matches the
					// corresponding podAffinityTerm; the
					// node(s) with the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							// If it's null, this PodAffinityTerm matches with no Pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select which pods
							// will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key in (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both matchLabelKeys and
							// labelSelector.
							// Also, matchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							matchLabelKeys?: [...string]

							// MismatchLabelKeys is a set of pod label keys to select which
							// pods will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// 'labelSelector' as 'key notin (value)'
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both mismatchLabelKeys
							// and labelSelector.
							// Also, mismatchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is an alpha field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate.
							mismatchLabelKeys?: [...string]

							// A label query over the set of namespaces that the term applies
							// to.
							// The term is applied to the union of the namespaces selected by
							// this field
							// and the ones listed in the namespaces field.
							// null selector and null or empty namespaces list means "this
							// pod's namespace".
							// An empty selector ({}) matches all namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to.
							// The term is applied to the union of the namespaces listed in
							// this field
							// and the ones selected by namespaceSelector.
							// null or empty namespaces list and null namespaceSelector means
							// "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching
							// the labelSelector in the specified namespaces, where co-located
							// is defined as running on a node
							// whose value of the label with key topologyKey matches that of
							// any node on which any of the
							// selected pods is running.
							// Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm,
						// in the range 1-100.
						weight: int
					}]

					// If the anti-affinity requirements specified by this field are
					// not met at
					// scheduling time, the pod will not be scheduled onto the node.
					// If the anti-affinity requirements specified by this field cease
					// to be met
					// at some point during pod execution (e.g. due to a pod label
					// update), the
					// system may or may not try to eventually evict the pod from its
					// node.
					// When there are multiple elements, the lists of nodes
					// corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						// If it's null, this PodAffinityTerm matches with no Pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select which pods
						// will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key in (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both matchLabelKeys and
						// labelSelector.
						// Also, matchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						matchLabelKeys?: [...string]

						// MismatchLabelKeys is a set of pod label keys to select which
						// pods will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// 'labelSelector' as 'key notin (value)'
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both mismatchLabelKeys
						// and labelSelector.
						// Also, mismatchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is an alpha field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate.
						mismatchLabelKeys?: [...string]

						// A label query over the set of namespaces that the term applies
						// to.
						// The term is applied to the union of the namespaces selected by
						// this field
						// and the ones listed in the namespaces field.
						// null selector and null or empty namespaces list means "this
						// pod's namespace".
						// An empty selector ({}) matches all namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to.
						// The term is applied to the union of the namespaces listed in
						// this field
						// and the ones selected by namespaceSelector.
						// null or empty namespaces list and null namespaceSelector means
						// "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching
						// the labelSelector in the specified namespaces, where co-located
						// is defined as running on a node
						// whose value of the label with key topologyKey matches that of
						// any node on which any of the
						// selected pods is running.
						// Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}
			}

			// nodeSelector is the node selector applied to the relevant kind
			// of pods
			// It specifies a map of key-value pairs: for the pod to be
			// eligible to run on a node,
			// the node must have each of the indicated key-value pairs as
			// labels
			// (it can have additional labels as well).
			// See
			// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
			nodeSelector?: {
				[string]: string
			}

			// tolerations is a list of tolerations applied to the relevant
			// kind of pods
			// See
			// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
			// for more info.
			// These are additional tolerations other than default ones.
			tolerations?: [...{
				// Effect indicates the taint effect to match. Empty means match
				// all taint effects.
				// When specified, allowed values are NoSchedule, PreferNoSchedule
				// and NoExecute.
				effect?: string

				// Key is the taint key that the toleration applies to. Empty
				// means match all taint keys.
				// If the key is empty, operator must be Exists; this combination
				// means to match all values and all keys.
				key?: string

				// Operator represents a key's relationship to the value.
				// Valid operators are Exists and Equal. Defaults to Equal.
				// Exists is equivalent to wildcard for value, so that a pod can
				// tolerate all taints of a particular category.
				operator?: string

				// TolerationSeconds represents the period of time the toleration
				// (which must be
				// of effect NoExecute, otherwise this field is ignored) tolerates
				// the taint. By default,
				// it is not set, which means tolerate the taint forever (do not
				// evict). Zero and
				// negative values will be treated as 0 (evict immediately) by the
				// system.
				tolerationSeconds?: int

				// Value is the taint value the toleration matches to.
				// If the operator is Exists, the value should be empty, otherwise
				// just a regular string.
				value?: string
			}]
		}

		// replicas indicates how many replicas should be created for each
		// KubeVirt infrastructure
		// component (like virt-api or virt-controller). Defaults to 2.
		// WARNING: this is an advanced feature that prevents auto-scaling
		// for core kubevirt components. Please use with caution!
		replicas?: int
	}
}

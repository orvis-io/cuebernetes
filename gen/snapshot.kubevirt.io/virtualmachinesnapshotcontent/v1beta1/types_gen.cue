// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f crds.yaml

package v1beta1

import (
	"strings"
	"list"
)

// VirtualMachineSnapshotContent contains the snapshot data
#VirtualMachineSnapshotContent: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "snapshot.kubevirt.io/v1beta1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "VirtualMachineSnapshotContent"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// VirtualMachineSnapshotContentSpec is the spec for a
	// VirtualMachineSnapshotContent resource
	spec!: #VirtualMachineSnapshotContentSpec
}

// VirtualMachineSnapshotContentSpec is the spec for a
// VirtualMachineSnapshotContent resource
#VirtualMachineSnapshotContentSpec: {
	source: {
		virtualMachine?: {
			metadata?: null | {
				...
			}

			// VirtualMachineSpec contains the VirtualMachine specification.
			spec?: {
				// dataVolumeTemplates is a list of dataVolumes that the
				// VirtualMachineInstance template can reference.
				// DataVolumes in this list are dynamically created for the
				// VirtualMachine and are tied to the VirtualMachine's
				// life-cycle.
				dataVolumeTemplates?: [...null | {
					// APIVersion defines the versioned schema of this representation
					// of an object.
					// Servers should convert recognized schemas to the latest
					// internal value, and
					// may reject unrecognized values.
					// More info:
					// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
					apiVersion?: string

					// Kind is a string value representing the REST resource this
					// object represents.
					// Servers may infer this from the endpoint the client submits
					// requests to.
					// Cannot be updated.
					// In CamelCase.
					// More info:
					// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
					kind?: string
					metadata?: null | {}

					// DataVolumeSpec contains the DataVolume specification.
					spec: {
						// Checkpoints is a list of DataVolumeCheckpoints, representing
						// stages in a multistage import.
						checkpoints?: [...{
							// Current is the identifier of the snapshot created for this
							// checkpoint.
							current: string

							// Previous is the identifier of the snapshot from the previous
							// checkpoint.
							previous: string
						}]

						// DataVolumeContentType options: "kubevirt", "archive"
						contentType?: "kubevirt" | "archive"

						// FinalCheckpoint indicates whether the current
						// DataVolumeCheckpoint is the final checkpoint.
						finalCheckpoint?: bool

						// Preallocation controls whether storage for DataVolumes should
						// be allocated in advance.
						preallocation?: bool

						// PriorityClassName for Importer, Cloner and Uploader pod
						priorityClassName?: string

						// PVC is the PVC specification
						pvc?: {
							// accessModes contains the desired access modes the volume should
							// have.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
							accessModes?: [...string]

							// dataSource field can be used to specify either:
							// * An existing VolumeSnapshot object
							// (snapshot.storage.k8s.io/VolumeSnapshot)
							// * An existing PVC (PersistentVolumeClaim)
							// If the provisioner or an external controller can support the
							// specified data source,
							// it will create a new volume based on the contents of the
							// specified data source.
							// When the AnyVolumeDataSource feature gate is enabled,
							// dataSource contents will be copied to dataSourceRef,
							// and dataSourceRef contents will be copied to dataSource when
							// dataSourceRef.namespace is not specified.
							// If the namespace is specified, then dataSourceRef will not be
							// copied to dataSource.
							dataSource?: {
								// APIGroup is the group for the resource being referenced.
								// If APIGroup is not specified, the specified Kind must be in the
								// core API group.
								// For any other third-party types, APIGroup is required.
								apiGroup?: string

								// Kind is the type of resource being referenced
								kind: string

								// Name is the name of resource being referenced
								name: string
							}

							// dataSourceRef specifies the object from which to populate the
							// volume with data, if a non-empty
							// volume is desired. This may be any object from a non-empty API
							// group (non
							// core object) or a PersistentVolumeClaim object.
							// When this field is specified, volume binding will only succeed
							// if the type of
							// the specified object matches some installed volume populator or
							// dynamic
							// provisioner.
							// This field will replace the functionality of the dataSource
							// field and as such
							// if both fields are non-empty, they must have the same value.
							// For backwards
							// compatibility, when namespace isn't specified in dataSourceRef,
							// both fields (dataSource and dataSourceRef) will be set to the
							// same
							// value automatically if one of them is empty and the other is
							// non-empty.
							// When namespace is specified in dataSourceRef,
							// dataSource isn't set to the same value and must be empty.
							// There are three important differences between dataSource and
							// dataSourceRef:
							// * While dataSource only allows two specific types of objects,
							// dataSourceRef
							// allows any non-core object, as well as PersistentVolumeClaim
							// objects.
							// * While dataSource ignores disallowed values (dropping them),
							// dataSourceRef
							// preserves all values, and generates an error if a disallowed
							// value is
							// specified.
							// * While dataSource only allows local objects, dataSourceRef
							// allows objects
							// in any namespaces.
							// (Beta) Using this field requires the AnyVolumeDataSource
							// feature gate to be enabled.
							// (Alpha) Using the namespace field of dataSourceRef requires the
							// CrossNamespaceVolumeDataSource feature gate to be enabled.
							dataSourceRef?: {
								// APIGroup is the group for the resource being referenced.
								// If APIGroup is not specified, the specified Kind must be in the
								// core API group.
								// For any other third-party types, APIGroup is required.
								apiGroup?: string

								// Kind is the type of resource being referenced
								kind: string

								// Name is the name of resource being referenced
								name: string

								// Namespace is the namespace of resource being referenced
								// Note that when a namespace is specified, a
								// gateway.networking.k8s.io/ReferenceGrant object is required in
								// the referent namespace to allow that namespace's owner to
								// accept the reference. See the ReferenceGrant documentation for
								// details.
								// (Alpha) This field requires the CrossNamespaceVolumeDataSource
								// feature gate to be enabled.
								namespace?: string
							}

							// resources represents the minimum resources the volume should
							// have.
							// If RecoverVolumeExpansionFailure feature is enabled users are
							// allowed to specify resource requirements
							// that are lower than previous value but must still be higher
							// than capacity recorded in the
							// status field of the claim.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
							resources?: {
								// Limits describes the maximum amount of compute resources
								// allowed.
								// More info:
								// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
								limits?: {
									[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// Requests describes the minimum amount of compute resources
								// required.
								// If Requests is omitted for a container, it defaults to Limits
								// if that is explicitly specified,
								// otherwise to an implementation-defined value. Requests cannot
								// exceed Limits.
								// More info:
								// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
								requests?: {
									[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
							}

							// selector is a label query over volumes to consider for binding.
							selector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// storageClassName is the name of the StorageClass required by
							// the claim.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
							storageClassName?: string

							// volumeAttributesClassName may be used to set the
							// VolumeAttributesClass used by this claim.
							// If specified, the CSI driver will create or update the volume
							// with the attributes defined
							// in the corresponding VolumeAttributesClass. This has a
							// different purpose than storageClassName,
							// it can be changed after the claim is created. An empty string
							// value means that no VolumeAttributesClass
							// will be applied to the claim but it's not allowed to reset this
							// field to empty string once it is set.
							// If unspecified and the PersistentVolumeClaim is unbound, the
							// default VolumeAttributesClass
							// will be set by the persistentvolume controller if it exists.
							// If the resource referred to by volumeAttributesClass does not
							// exist, this PersistentVolumeClaim will be
							// set to a Pending state, as reflected by the modifyVolumeStatus
							// field, until such as a resource
							// exists.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
							// (Alpha) Using this field requires the VolumeAttributesClass
							// feature gate to be enabled.
							volumeAttributesClassName?: string

							// volumeMode defines what type of volume is required by the
							// claim.
							// Value of Filesystem is implied when not included in claim spec.
							volumeMode?: string

							// volumeName is the binding reference to the PersistentVolume
							// backing this claim.
							volumeName?: string
						}

						// Source is the src of the data for the requested DataVolume
						source?: {
							// DataVolumeBlankImage provides the parameters to create a new
							// raw blank image for the PVC
							blank?: {}

							// DataVolumeSourceGCS provides the parameters to create a Data
							// Volume from an GCS source
							gcs?: {
								// SecretRef provides the secret reference needed to access the
								// GCS source
								secretRef?: string

								// URL is the url of the GCS source
								url: string
							}

							// DataVolumeSourceHTTP can be either an http or https endpoint,
							// with an optional basic auth user name and password, and an
							// optional configmap containing additional CAs
							http?: {
								// CertConfigMap is a configmap reference, containing a
								// Certificate Authority(CA) public key, and a base64 encoded pem
								// certificate
								certConfigMap?: string

								// ExtraHeaders is a list of strings containing extra headers to
								// include with HTTP transfer requests
								extraHeaders?: [...string]

								// SecretExtraHeaders is a list of Secret references, each
								// containing an extra HTTP header that may include sensitive
								// information
								secretExtraHeaders?: [...string]

								// SecretRef A Secret reference, the secret should contain
								// accessKeyId (user name) base64 encoded, and secretKey
								// (password) also base64 encoded
								secretRef?: string

								// URL is the URL of the http(s) endpoint
								url: string
							}

							// DataVolumeSourceImageIO provides the parameters to create a
							// Data Volume from an imageio source
							imageio?: {
								// CertConfigMap provides a reference to the CA cert
								certConfigMap?: string

								// DiskID provides id of a disk to be imported
								diskId: string

								// SecretRef provides the secret reference needed to access the
								// ovirt-engine
								secretRef?: string

								// URL is the URL of the ovirt-engine
								url: string
							}

							// DataVolumeSourcePVC provides the parameters to create a Data
							// Volume from an existing PVC
							pvc?: {
								// The name of the source PVC
								name: string

								// The namespace of the source PVC
								namespace: string
							}

							// DataVolumeSourceRegistry provides the parameters to create a
							// Data Volume from an registry source
							registry?: {
								// CertConfigMap provides a reference to the Registry certs
								certConfigMap?: string

								// ImageStream is the name of image stream for import
								imageStream?: string

								// PullMethod can be either "pod" (default import), or "node"
								// (node docker cache based import)
								pullMethod?: string

								// SecretRef provides the secret reference needed to access the
								// Registry source
								secretRef?: string

								// URL is the url of the registry source (starting with the
								// scheme: docker, oci-archive)
								url?: string
							}

							// DataVolumeSourceS3 provides the parameters to create a Data
							// Volume from an S3 source
							s3?: {
								// CertConfigMap is a configmap reference, containing a
								// Certificate Authority(CA) public key, and a base64 encoded pem
								// certificate
								certConfigMap?: string

								// SecretRef provides the secret reference needed to access the S3
								// source
								secretRef?: string

								// URL is the url of the S3 source
								url: string
							}

							// DataVolumeSourceSnapshot provides the parameters to create a
							// Data Volume from an existing VolumeSnapshot
							snapshot?: {
								// The name of the source VolumeSnapshot
								name: string

								// The namespace of the source VolumeSnapshot
								namespace: string
							}

							// DataVolumeSourceUpload provides the parameters to create a Data
							// Volume by uploading the source
							upload?: {}

							// DataVolumeSourceVDDK provides the parameters to create a Data
							// Volume from a Vmware source
							vddk?: {
								// BackingFile is the path to the virtual hard disk to migrate
								// from vCenter/ESXi
								backingFile?: string

								// InitImageURL is an optional URL to an image containing an
								// extracted VDDK library, overrides v2v-vmware config map
								initImageURL?: string

								// SecretRef provides a reference to a secret containing the
								// username and password needed to access the vCenter or ESXi
								// host
								secretRef?: string

								// Thumbprint is the certificate thumbprint of the vCenter or ESXi
								// host
								thumbprint?: string

								// URL is the URL of the vCenter or ESXi host with the VM to
								// migrate
								url?: string

								// UUID is the UUID of the virtual machine that the backing file
								// is attached to in vCenter/ESXi
								uuid?: string
							}
						}

						// SourceRef is an indirect reference to the source of data for
						// the requested DataVolume
						sourceRef?: {
							// The kind of the source reference, currently only "DataSource"
							// is supported
							kind: string

							// The name of the source reference
							name: string

							// The namespace of the source reference, defaults to the
							// DataVolume namespace
							namespace?: string
						}

						// Storage is the requested storage specification
						storage?: {
							// AccessModes contains the desired access modes the volume should
							// have.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
							accessModes?: [...string]

							// This field can be used to specify either: * An existing
							// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
							// * An existing PVC (PersistentVolumeClaim) * An existing custom
							// resource that implements data population (Alpha) In order to
							// use custom resource types that implement data population, the
							// AnyVolumeDataSource feature gate must be enabled. If the
							// provisioner or an external controller can support the
							// specified data source, it will create a new volume based on
							// the contents of the specified data source.
							// If the AnyVolumeDataSource feature gate is enabled, this field
							// will always have the same contents as the DataSourceRef field.
							dataSource?: {
								// APIGroup is the group for the resource being referenced.
								// If APIGroup is not specified, the specified Kind must be in the
								// core API group.
								// For any other third-party types, APIGroup is required.
								apiGroup?: string

								// Kind is the type of resource being referenced
								kind: string

								// Name is the name of resource being referenced
								name: string
							}

							// Specifies the object from which to populate the volume with
							// data, if a non-empty volume is desired. This may be any local
							// object from a non-empty API group (non core object) or a
							// PersistentVolumeClaim object. When this field is specified,
							// volume binding will only succeed if the type of the specified
							// object matches some installed volume populator or dynamic
							// provisioner.
							// This field will replace the functionality of the DataSource
							// field and as such if both fields are non-empty, they must have
							// the same value. For backwards compatibility, both fields
							// (DataSource and DataSourceRef) will be set to the same value
							// automatically if one of them is empty and the other is
							// non-empty.
							// There are two important differences between DataSource and
							// DataSourceRef:
							// * While DataSource only allows two specific types of objects,
							// DataSourceRef allows any non-core object, as well as
							// PersistentVolumeClaim objects.
							// * While DataSource ignores disallowed values (dropping them),
							// DataSourceRef preserves all values, and generates an error if
							// a disallowed value is specified.
							// (Beta) Using this field requires the AnyVolumeDataSource
							// feature gate to be enabled.
							dataSourceRef?: {
								// APIGroup is the group for the resource being referenced.
								// If APIGroup is not specified, the specified Kind must be in the
								// core API group.
								// For any other third-party types, APIGroup is required.
								apiGroup?: string

								// Kind is the type of resource being referenced
								kind: string

								// Name is the name of resource being referenced
								name: string

								// Namespace is the namespace of resource being referenced
								// Note that when a namespace is specified, a
								// gateway.networking.k8s.io/ReferenceGrant object is required in
								// the referent namespace to allow that namespace's owner to
								// accept the reference. See the ReferenceGrant documentation for
								// details.
								// (Alpha) This field requires the CrossNamespaceVolumeDataSource
								// feature gate to be enabled.
								namespace?: string
							}

							// Resources represents the minimum resources the volume should
							// have.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
							resources?: {
								// Claims lists the names of resources, defined in
								// spec.resourceClaims,
								// that are used by this container.
								//
								//
								// This is an alpha field and requires enabling the
								// DynamicResourceAllocation feature gate.
								//
								//
								// This field is immutable. It can only be set for containers.
								claims?: [...{
									// Name must match the name of one entry in
									// pod.spec.resourceClaims of
									// the Pod where this field is used. It makes that resource
									// available
									// inside a container.
									name: string
								}]

								// Limits describes the maximum amount of compute resources
								// allowed.
								// More info:
								// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
								limits?: {
									[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// Requests describes the minimum amount of compute resources
								// required.
								// If Requests is omitted for a container, it defaults to Limits
								// if that is explicitly specified,
								// otherwise to an implementation-defined value. Requests cannot
								// exceed Limits.
								// More info:
								// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
								requests?: {
									[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
							}

							// A label query over volumes to consider for binding.
							selector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// Name of the StorageClass required by the claim.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
							storageClassName?: string

							// volumeMode defines what type of volume is required by the
							// claim.
							// Value of Filesystem is implied when not included in claim spec.
							volumeMode?: string

							// VolumeName is the binding reference to the PersistentVolume
							// backing this claim.
							volumeName?: string
						}
					}

					// DataVolumeTemplateDummyStatus is here simply for backwards
					// compatibility with
					// a previous API.
					status?: null | {}
				}]

				// InstancetypeMatcher references a instancetype that is used to
				// fill fields in Template
				instancetype?: {
					// InferFromVolume lists the name of a volume that should be used
					// to infer or discover the instancetype
					// to be used through known annotations on the underlying
					// resource. Once applied to the InstancetypeMatcher
					// this field is removed.
					inferFromVolume?: string

					// InferFromVolumeFailurePolicy controls what should happen on
					// failure when inferring the instancetype.
					// Allowed values are: "RejectInferFromVolumeFailure" and
					// "IgnoreInferFromVolumeFailure".
					// If not specified, "RejectInferFromVolumeFailure" is used by
					// default.
					inferFromVolumeFailurePolicy?: string

					// Kind specifies which instancetype resource is referenced.
					// Allowed values are: "VirtualMachineInstancetype" and
					// "VirtualMachineClusterInstancetype".
					// If not specified, "VirtualMachineClusterInstancetype" is used
					// by default.
					kind?: string

					// Name is the name of the VirtualMachineInstancetype or
					// VirtualMachineClusterInstancetype
					name?: string

					// RevisionName specifies a ControllerRevision containing a
					// specific copy of the
					// VirtualMachineInstancetype or VirtualMachineClusterInstancetype
					// to be used. This is initially
					// captured the first time the instancetype is applied to the
					// VirtualMachineInstance.
					revisionName?: string
				}

				// PreferenceMatcher references a set of preference that is used
				// to fill fields in Template
				preference?: {
					// InferFromVolume lists the name of a volume that should be used
					// to infer or discover the preference
					// to be used through known annotations on the underlying
					// resource. Once applied to the PreferenceMatcher
					// this field is removed.
					inferFromVolume?: string

					// InferFromVolumeFailurePolicy controls what should happen on
					// failure when preference the instancetype.
					// Allowed values are: "RejectInferFromVolumeFailure" and
					// "IgnoreInferFromVolumeFailure".
					// If not specified, "RejectInferFromVolumeFailure" is used by
					// default.
					inferFromVolumeFailurePolicy?: string

					// Kind specifies which preference resource is referenced.
					// Allowed values are: "VirtualMachinePreference" and
					// "VirtualMachineClusterPreference".
					// If not specified, "VirtualMachineClusterPreference" is used by
					// default.
					kind?: string

					// Name is the name of the VirtualMachinePreference or
					// VirtualMachineClusterPreference
					name?: string

					// RevisionName specifies a ControllerRevision containing a
					// specific copy of the
					// VirtualMachinePreference or VirtualMachineClusterPreference to
					// be used. This is
					// initially captured the first time the instancetype is applied
					// to the VirtualMachineInstance.
					revisionName?: string
				}

				// Running state indicates the requested running state of the
				// VirtualMachineInstance
				// mutually exclusive with Running
				runStrategy?: string

				// Running controls whether the associatied VirtualMachineInstance
				// is created or not
				// Mutually exclusive with RunStrategy
				running?: bool

				// Template is the direct specification of VirtualMachineInstance
				template: {
					metadata?: null | {
						...
					}

					// VirtualMachineInstance Spec contains the VirtualMachineInstance
					// specification.
					spec?: {
						// Specifies a set of public keys to inject into the vm guest
						accessCredentials?: list.MaxItems(256) & [...{
							// SSHPublicKey represents the source and method of applying a ssh
							// public
							// key into a guest virtual machine.
							sshPublicKey?: {
								// PropagationMethod represents how the public key is injected
								// into the vm guest.
								propagationMethod: {
									// ConfigDrivePropagation means that the ssh public keys are
									// injected
									// into the VM using metadata using the configDrive cloud-init
									// provider
									configDrive?: {}

									// NoCloudPropagation means that the ssh public keys are injected
									// into the VM using metadata using the noCloud cloud-init
									// provider
									noCloud?: {}
									qemuGuestAgent?: {
										// Users represents a list of guest users that should have the ssh
										// public keys
										// added to their authorized_keys file.
										users: [...string]
									}
								}
								source: {
									secret?: {
										// SecretName represents the name of the secret in the VMI's
										// namespace
										secretName: string
									}
								}
							}

							// UserPassword represents the source and method for applying a
							// guest user's
							// password
							userPassword?: {
								propagationMethod: {
									// QemuGuestAgentAccessCredentailPropagation means passwords are
									// dynamically injected into the vm at runtime via the qemu guest
									// agent.
									// This feature requires the qemu guest agent to be running within
									// the guest.
									qemuGuestAgent?: {}
								}
								source: {
									secret?: {
										// SecretName represents the name of the secret in the VMI's
										// namespace
										secretName: string
									}
								}
							}
						}]

						// If affinity is specifies, obey all the affinity rules
						affinity?: {
							// Describes node affinity scheduling rules for the pod.
							nodeAffinity?: {
								// The scheduler will prefer to schedule pods to nodes that
								// satisfy
								// the affinity expressions specified by this field, but it may
								// choose
								// a node that violates one or more of the expressions. The node
								// that is
								// most preferred is the one with the greatest sum of weights,
								// i.e.
								// for each node that meets all of the scheduling requirements
								// (resource
								// request, requiredDuringScheduling affinity expressions, etc.),
								// compute a sum by iterating through the elements of this field
								// and adding
								// "weight" to the sum if the node matches the corresponding
								// matchExpressions; the
								// node(s) with the highest sum are the most preferred.
								preferredDuringSchedulingIgnoredDuringExecution?: [...{
									// A node selector term, associated with the corresponding weight.
									preference: {
										// A list of node selector requirements by node's labels.
										matchExpressions?: [...{
											// The label key that the selector applies to.
											key: string

											// Represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
											// Lt.
											operator: string

											// An array of string values. If the operator is In or NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. If the operator is Gt or Lt,
											// the values
											// array must have a single element, which will be interpreted as
											// an integer.
											// This array is replaced during a strategic merge patch.
											values?: [...string]
										}]

										// A list of node selector requirements by node's fields.
										matchFields?: [...{
											// The label key that the selector applies to.
											key: string

											// Represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
											// Lt.
											operator: string

											// An array of string values. If the operator is In or NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. If the operator is Gt or Lt,
											// the values
											// array must have a single element, which will be interpreted as
											// an integer.
											// This array is replaced during a strategic merge patch.
											values?: [...string]
										}]
									}

									// Weight associated with matching the corresponding
									// nodeSelectorTerm, in the range 1-100.
									weight: int
								}]
								requiredDuringSchedulingIgnoredDuringExecution?: {
									// Required. A list of node selector terms. The terms are ORed.
									nodeSelectorTerms: [...{
										// A list of node selector requirements by node's labels.
										matchExpressions?: [...{
											// The label key that the selector applies to.
											key: string

											// Represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
											// Lt.
											operator: string

											// An array of string values. If the operator is In or NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. If the operator is Gt or Lt,
											// the values
											// array must have a single element, which will be interpreted as
											// an integer.
											// This array is replaced during a strategic merge patch.
											values?: [...string]
										}]

										// A list of node selector requirements by node's fields.
										matchFields?: [...{
											// The label key that the selector applies to.
											key: string

											// Represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
											// Lt.
											operator: string

											// An array of string values. If the operator is In or NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. If the operator is Gt or Lt,
											// the values
											// array must have a single element, which will be interpreted as
											// an integer.
											// This array is replaced during a strategic merge patch.
											values?: [...string]
										}]
									}]
								}
							}

							// Describes pod affinity scheduling rules (e.g. co-locate this
							// pod in the same node, zone, etc. as some other pod(s)).
							podAffinity?: {
								// The scheduler will prefer to schedule pods to nodes that
								// satisfy
								// the affinity expressions specified by this field, but it may
								// choose
								// a node that violates one or more of the expressions. The node
								// that is
								// most preferred is the one with the greatest sum of weights,
								// i.e.
								// for each node that meets all of the scheduling requirements
								// (resource
								// request, requiredDuringScheduling affinity expressions, etc.),
								// compute a sum by iterating through the elements of this field
								// and adding
								// "weight" to the sum if the node has pods which matches the
								// corresponding podAffinityTerm; the
								// node(s) with the highest sum are the most preferred.
								preferredDuringSchedulingIgnoredDuringExecution?: [...{
									// Required. A pod affinity term, associated with the
									// corresponding weight.
									podAffinityTerm: {
										// A label query over a set of resources, in this case pods.
										// If it's null, this PodAffinityTerm matches with no Pods.
										labelSelector?: {
											// matchExpressions is a list of label selector requirements. The
											// requirements are ANDed.
											matchExpressions?: [...{
												// key is the label key that the selector applies to.
												key: string

												// operator represents a key's relationship to a set of values.
												// Valid operators are In, NotIn, Exists and DoesNotExist.
												operator: string

												// values is an array of string values. If the operator is In or
												// NotIn,
												// the values array must be non-empty. If the operator is Exists
												// or DoesNotExist,
												// the values array must be empty. This array is replaced during a
												// strategic
												// merge patch.
												values?: [...string]
											}]

											// matchLabels is a map of {key,value} pairs. A single {key,value}
											// in the matchLabels
											// map is equivalent to an element of matchExpressions, whose key
											// field is "key", the
											// operator is "In", and the values array contains only "value".
											// The requirements are ANDed.
											matchLabels?: {
												[string]: string
											}
										}

										// MatchLabelKeys is a set of pod label keys to select which pods
										// will
										// be taken into consideration. The keys are used to lookup values
										// from the
										// incoming pod labels, those key-value labels are merged with
										// 'labelSelector' as 'key in (value)'
										// to select the group of existing pods which pods will be taken
										// into consideration
										// for the incoming pod's pod (anti) affinity. Keys that don't
										// exist in the incoming
										// pod labels will be ignored. The default value is empty.
										// The same key is forbidden to exist in both matchLabelKeys and
										// labelSelector.
										// Also, matchLabelKeys cannot be set when labelSelector isn't
										// set.
										// This is an alpha field and requires enabling
										// MatchLabelKeysInPodAffinity feature gate.
										matchLabelKeys?: [...string]

										// MismatchLabelKeys is a set of pod label keys to select which
										// pods will
										// be taken into consideration. The keys are used to lookup values
										// from the
										// incoming pod labels, those key-value labels are merged with
										// 'labelSelector' as 'key notin (value)'
										// to select the group of existing pods which pods will be taken
										// into consideration
										// for the incoming pod's pod (anti) affinity. Keys that don't
										// exist in the incoming
										// pod labels will be ignored. The default value is empty.
										// The same key is forbidden to exist in both mismatchLabelKeys
										// and labelSelector.
										// Also, mismatchLabelKeys cannot be set when labelSelector isn't
										// set.
										// This is an alpha field and requires enabling
										// MatchLabelKeysInPodAffinity feature gate.
										mismatchLabelKeys?: [...string]

										// A label query over the set of namespaces that the term applies
										// to.
										// The term is applied to the union of the namespaces selected by
										// this field
										// and the ones listed in the namespaces field.
										// null selector and null or empty namespaces list means "this
										// pod's namespace".
										// An empty selector ({}) matches all namespaces.
										namespaceSelector?: {
											// matchExpressions is a list of label selector requirements. The
											// requirements are ANDed.
											matchExpressions?: [...{
												// key is the label key that the selector applies to.
												key: string

												// operator represents a key's relationship to a set of values.
												// Valid operators are In, NotIn, Exists and DoesNotExist.
												operator: string

												// values is an array of string values. If the operator is In or
												// NotIn,
												// the values array must be non-empty. If the operator is Exists
												// or DoesNotExist,
												// the values array must be empty. This array is replaced during a
												// strategic
												// merge patch.
												values?: [...string]
											}]

											// matchLabels is a map of {key,value} pairs. A single {key,value}
											// in the matchLabels
											// map is equivalent to an element of matchExpressions, whose key
											// field is "key", the
											// operator is "In", and the values array contains only "value".
											// The requirements are ANDed.
											matchLabels?: {
												[string]: string
											}
										}

										// namespaces specifies a static list of namespace names that the
										// term applies to.
										// The term is applied to the union of the namespaces listed in
										// this field
										// and the ones selected by namespaceSelector.
										// null or empty namespaces list and null namespaceSelector means
										// "this pod's namespace".
										namespaces?: [...string]

										// This pod should be co-located (affinity) or not co-located
										// (anti-affinity) with the pods matching
										// the labelSelector in the specified namespaces, where co-located
										// is defined as running on a node
										// whose value of the label with key topologyKey matches that of
										// any node on which any of the
										// selected pods is running.
										// Empty topologyKey is not allowed.
										topologyKey: string
									}

									// weight associated with matching the corresponding
									// podAffinityTerm,
									// in the range 1-100.
									weight: int
								}]

								// If the affinity requirements specified by this field are not
								// met at
								// scheduling time, the pod will not be scheduled onto the node.
								// If the affinity requirements specified by this field cease to
								// be met
								// at some point during pod execution (e.g. due to a pod label
								// update), the
								// system may or may not try to eventually evict the pod from its
								// node.
								// When there are multiple elements, the lists of nodes
								// corresponding to each
								// podAffinityTerm are intersected, i.e. all terms must be
								// satisfied.
								requiredDuringSchedulingIgnoredDuringExecution?: [...{
									// A label query over a set of resources, in this case pods.
									// If it's null, this PodAffinityTerm matches with no Pods.
									labelSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// MatchLabelKeys is a set of pod label keys to select which pods
									// will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// 'labelSelector' as 'key in (value)'
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both matchLabelKeys and
									// labelSelector.
									// Also, matchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									matchLabelKeys?: [...string]

									// MismatchLabelKeys is a set of pod label keys to select which
									// pods will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// 'labelSelector' as 'key notin (value)'
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both mismatchLabelKeys
									// and labelSelector.
									// Also, mismatchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									mismatchLabelKeys?: [...string]

									// A label query over the set of namespaces that the term applies
									// to.
									// The term is applied to the union of the namespaces selected by
									// this field
									// and the ones listed in the namespaces field.
									// null selector and null or empty namespaces list means "this
									// pod's namespace".
									// An empty selector ({}) matches all namespaces.
									namespaceSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// namespaces specifies a static list of namespace names that the
									// term applies to.
									// The term is applied to the union of the namespaces listed in
									// this field
									// and the ones selected by namespaceSelector.
									// null or empty namespaces list and null namespaceSelector means
									// "this pod's namespace".
									namespaces?: [...string]

									// This pod should be co-located (affinity) or not co-located
									// (anti-affinity) with the pods matching
									// the labelSelector in the specified namespaces, where co-located
									// is defined as running on a node
									// whose value of the label with key topologyKey matches that of
									// any node on which any of the
									// selected pods is running.
									// Empty topologyKey is not allowed.
									topologyKey: string
								}]
							}

							// Describes pod anti-affinity scheduling rules (e.g. avoid
							// putting this pod in the same node, zone, etc. as some other
							// pod(s)).
							podAntiAffinity?: {
								// The scheduler will prefer to schedule pods to nodes that
								// satisfy
								// the anti-affinity expressions specified by this field, but it
								// may choose
								// a node that violates one or more of the expressions. The node
								// that is
								// most preferred is the one with the greatest sum of weights,
								// i.e.
								// for each node that meets all of the scheduling requirements
								// (resource
								// request, requiredDuringScheduling anti-affinity expressions,
								// etc.),
								// compute a sum by iterating through the elements of this field
								// and adding
								// "weight" to the sum if the node has pods which matches the
								// corresponding podAffinityTerm; the
								// node(s) with the highest sum are the most preferred.
								preferredDuringSchedulingIgnoredDuringExecution?: [...{
									// Required. A pod affinity term, associated with the
									// corresponding weight.
									podAffinityTerm: {
										// A label query over a set of resources, in this case pods.
										// If it's null, this PodAffinityTerm matches with no Pods.
										labelSelector?: {
											// matchExpressions is a list of label selector requirements. The
											// requirements are ANDed.
											matchExpressions?: [...{
												// key is the label key that the selector applies to.
												key: string

												// operator represents a key's relationship to a set of values.
												// Valid operators are In, NotIn, Exists and DoesNotExist.
												operator: string

												// values is an array of string values. If the operator is In or
												// NotIn,
												// the values array must be non-empty. If the operator is Exists
												// or DoesNotExist,
												// the values array must be empty. This array is replaced during a
												// strategic
												// merge patch.
												values?: [...string]
											}]

											// matchLabels is a map of {key,value} pairs. A single {key,value}
											// in the matchLabels
											// map is equivalent to an element of matchExpressions, whose key
											// field is "key", the
											// operator is "In", and the values array contains only "value".
											// The requirements are ANDed.
											matchLabels?: {
												[string]: string
											}
										}

										// MatchLabelKeys is a set of pod label keys to select which pods
										// will
										// be taken into consideration. The keys are used to lookup values
										// from the
										// incoming pod labels, those key-value labels are merged with
										// 'labelSelector' as 'key in (value)'
										// to select the group of existing pods which pods will be taken
										// into consideration
										// for the incoming pod's pod (anti) affinity. Keys that don't
										// exist in the incoming
										// pod labels will be ignored. The default value is empty.
										// The same key is forbidden to exist in both matchLabelKeys and
										// labelSelector.
										// Also, matchLabelKeys cannot be set when labelSelector isn't
										// set.
										// This is an alpha field and requires enabling
										// MatchLabelKeysInPodAffinity feature gate.
										matchLabelKeys?: [...string]

										// MismatchLabelKeys is a set of pod label keys to select which
										// pods will
										// be taken into consideration. The keys are used to lookup values
										// from the
										// incoming pod labels, those key-value labels are merged with
										// 'labelSelector' as 'key notin (value)'
										// to select the group of existing pods which pods will be taken
										// into consideration
										// for the incoming pod's pod (anti) affinity. Keys that don't
										// exist in the incoming
										// pod labels will be ignored. The default value is empty.
										// The same key is forbidden to exist in both mismatchLabelKeys
										// and labelSelector.
										// Also, mismatchLabelKeys cannot be set when labelSelector isn't
										// set.
										// This is an alpha field and requires enabling
										// MatchLabelKeysInPodAffinity feature gate.
										mismatchLabelKeys?: [...string]

										// A label query over the set of namespaces that the term applies
										// to.
										// The term is applied to the union of the namespaces selected by
										// this field
										// and the ones listed in the namespaces field.
										// null selector and null or empty namespaces list means "this
										// pod's namespace".
										// An empty selector ({}) matches all namespaces.
										namespaceSelector?: {
											// matchExpressions is a list of label selector requirements. The
											// requirements are ANDed.
											matchExpressions?: [...{
												// key is the label key that the selector applies to.
												key: string

												// operator represents a key's relationship to a set of values.
												// Valid operators are In, NotIn, Exists and DoesNotExist.
												operator: string

												// values is an array of string values. If the operator is In or
												// NotIn,
												// the values array must be non-empty. If the operator is Exists
												// or DoesNotExist,
												// the values array must be empty. This array is replaced during a
												// strategic
												// merge patch.
												values?: [...string]
											}]

											// matchLabels is a map of {key,value} pairs. A single {key,value}
											// in the matchLabels
											// map is equivalent to an element of matchExpressions, whose key
											// field is "key", the
											// operator is "In", and the values array contains only "value".
											// The requirements are ANDed.
											matchLabels?: {
												[string]: string
											}
										}

										// namespaces specifies a static list of namespace names that the
										// term applies to.
										// The term is applied to the union of the namespaces listed in
										// this field
										// and the ones selected by namespaceSelector.
										// null or empty namespaces list and null namespaceSelector means
										// "this pod's namespace".
										namespaces?: [...string]

										// This pod should be co-located (affinity) or not co-located
										// (anti-affinity) with the pods matching
										// the labelSelector in the specified namespaces, where co-located
										// is defined as running on a node
										// whose value of the label with key topologyKey matches that of
										// any node on which any of the
										// selected pods is running.
										// Empty topologyKey is not allowed.
										topologyKey: string
									}

									// weight associated with matching the corresponding
									// podAffinityTerm,
									// in the range 1-100.
									weight: int
								}]

								// If the anti-affinity requirements specified by this field are
								// not met at
								// scheduling time, the pod will not be scheduled onto the node.
								// If the anti-affinity requirements specified by this field cease
								// to be met
								// at some point during pod execution (e.g. due to a pod label
								// update), the
								// system may or may not try to eventually evict the pod from its
								// node.
								// When there are multiple elements, the lists of nodes
								// corresponding to each
								// podAffinityTerm are intersected, i.e. all terms must be
								// satisfied.
								requiredDuringSchedulingIgnoredDuringExecution?: [...{
									// A label query over a set of resources, in this case pods.
									// If it's null, this PodAffinityTerm matches with no Pods.
									labelSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// MatchLabelKeys is a set of pod label keys to select which pods
									// will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// 'labelSelector' as 'key in (value)'
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both matchLabelKeys and
									// labelSelector.
									// Also, matchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									matchLabelKeys?: [...string]

									// MismatchLabelKeys is a set of pod label keys to select which
									// pods will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// 'labelSelector' as 'key notin (value)'
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both mismatchLabelKeys
									// and labelSelector.
									// Also, mismatchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									mismatchLabelKeys?: [...string]

									// A label query over the set of namespaces that the term applies
									// to.
									// The term is applied to the union of the namespaces selected by
									// this field
									// and the ones listed in the namespaces field.
									// null selector and null or empty namespaces list means "this
									// pod's namespace".
									// An empty selector ({}) matches all namespaces.
									namespaceSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// namespaces specifies a static list of namespace names that the
									// term applies to.
									// The term is applied to the union of the namespaces listed in
									// this field
									// and the ones selected by namespaceSelector.
									// null or empty namespaces list and null namespaceSelector means
									// "this pod's namespace".
									namespaces?: [...string]

									// This pod should be co-located (affinity) or not co-located
									// (anti-affinity) with the pods matching
									// the labelSelector in the specified namespaces, where co-located
									// is defined as running on a node
									// whose value of the label with key topologyKey matches that of
									// any node on which any of the
									// selected pods is running.
									// Empty topologyKey is not allowed.
									topologyKey: string
								}]
							}
						}

						// Specifies the architecture of the vm guest you are attempting
						// to run. Defaults to the compiled architecture of the KubeVirt
						// components
						architecture?: string

						// Specifies the DNS parameters of a pod.
						// Parameters specified here will be merged to the generated DNS
						// configuration based on DNSPolicy.
						dnsConfig?: {
							// A list of DNS name server IP addresses.
							// This will be appended to the base nameservers generated from
							// DNSPolicy.
							// Duplicated nameservers will be removed.
							nameservers?: [...string]

							// A list of DNS resolver options.
							// This will be merged with the base options generated from
							// DNSPolicy.
							// Duplicated entries will be removed. Resolution options given in
							// Options
							// will override those that appear in the base DNSPolicy.
							options?: [...{
								// Required.
								name?:  string
								value?: string
							}]

							// A list of DNS search domains for host-name lookup.
							// This will be appended to the base search paths generated from
							// DNSPolicy.
							// Duplicated search paths will be removed.
							searches?: [...string]
						}

						// Set DNS policy for the pod.
						// Defaults to "ClusterFirst".
						// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst',
						// 'Default' or 'None'.
						// DNS parameters given in DNSConfig will be merged with the
						// policy selected with DNSPolicy.
						// To have DNS options set along with hostNetwork, you have to
						// specify DNS policy
						// explicitly to 'ClusterFirstWithHostNet'.
						dnsPolicy?: string

						// Specification of the desired behavior of the
						// VirtualMachineInstance on the host.
						domain: {
							// Chassis specifies the chassis info passed to the domain.
							chassis?: {
								asset?:        string
								manufacturer?: string
								serial?:       string
								sku?:          string
								version?:      string
							}

							// Clock sets the clock and timers of the vmi.
							clock?: {
								// Timer specifies whih timers are attached to the vmi.
								timer?: {
									// HPET (High Precision Event Timer) - multiple timers with
									// periodic interrupts.
									hpet?: {
										// Enabled set to false makes sure that the machine type or a
										// preset can't add the timer.
										// Defaults to true.
										present?: bool

										// TickPolicy determines what happens when QEMU misses a deadline
										// for injecting a tick to the guest.
										// One of "delay", "catchup", "merge", "discard".
										tickPolicy?: string
									}
									hyperv?: {
										// Enabled set to false makes sure that the machine type or a
										// preset can't add the timer.
										// Defaults to true.
										present?: bool
									}
									kvm?: {
										// Enabled set to false makes sure that the machine type or a
										// preset can't add the timer.
										// Defaults to true.
										present?: bool
									}

									// PIT (Programmable Interval Timer) - a timer with periodic
									// interrupts.
									pit?: {
										// Enabled set to false makes sure that the machine type or a
										// preset can't add the timer.
										// Defaults to true.
										present?: bool

										// TickPolicy determines what happens when QEMU misses a deadline
										// for injecting a tick to the guest.
										// One of "delay", "catchup", "discard".
										tickPolicy?: string
									}

									// RTC (Real Time Clock) - a continuously running timer with
									// periodic interrupts.
									rtc?: {
										// Enabled set to false makes sure that the machine type or a
										// preset can't add the timer.
										// Defaults to true.
										present?: bool

										// TickPolicy determines what happens when QEMU misses a deadline
										// for injecting a tick to the guest.
										// One of "delay", "catchup".
										tickPolicy?: string

										// Track the guest or the wall clock.
										track?: string
									}
								}

								// Timezone sets the guest clock to the specified timezone.
								// Zone name follows the TZ environment variable format (e.g.
								// 'America/New_York').
								timezone?: string
								utc?: {
									// OffsetSeconds specifies an offset in seconds, relative to UTC.
									// If set,
									// guest changes to the clock will be kept during reboots and not
									// reset.
									offsetSeconds?: int
								}
								...
							}

							// CPU allow specified the detailed CPU topology inside the vmi.
							cpu?: {
								// Cores specifies the number of cores inside the vmi.
								// Must be a value greater or equal 1.
								cores?: int

								// DedicatedCPUPlacement requests the scheduler to place the
								// VirtualMachineInstance on a node
								// with enough dedicated pCPUs and pin the vCPUs to it.
								dedicatedCpuPlacement?: bool

								// Features specifies the CPU features list inside the VMI.
								features?: [...{
									// Name of the CPU feature
									name: string

									// Policy is the CPU feature attribute which can have the
									// following attributes:
									// force - The virtual CPU will claim the feature is supported
									// regardless of it being supported by host CPU.
									// require - Guest creation will fail unless the feature is
									// supported by the host CPU or the hypervisor is able to emulate
									// it.
									// optional - The feature will be supported by virtual CPU if and
									// only if it is supported by host CPU.
									// disable - The feature will not be supported by virtual CPU.
									// forbid - Guest creation will fail if the feature is supported
									// by host CPU.
									// Defaults to require
									policy?: string
								}]

								// IsolateEmulatorThread requests one more dedicated pCPU to be
								// allocated for the VMI to place
								// the emulator thread on it.
								isolateEmulatorThread?: bool

								// MaxSockets specifies the maximum amount of sockets that can
								// be hotplugged
								maxSockets?: int

								// Model specifies the CPU model inside the VMI.
								// List of available models
								// https://github.com/libvirt/libvirt/tree/master/src/cpu_map.
								// It is possible to specify special cases like "host-passthrough"
								// to get the same CPU as the node
								// and "host-model" to get CPU closest to the node one.
								// Defaults to host-model.
								model?: string
								numa?: {
									// GuestMappingPassthrough will create an efficient guest topology
									// based on host CPUs exclusively assigned to a pod.
									// The created topology ensures that memory and CPUs on the
									// virtual numa nodes never cross boundaries of host numa nodes.
									guestMappingPassthrough?: {}
								}
								realtime?: {
									// Mask defines the vcpu mask expression that defines which vcpus
									// are used for realtime. Format matches libvirt's expressions.
									// Example: "0-3,^1","0,2,3","2-3"
									mask?: string
								}

								// Sockets specifies the number of sockets inside the vmi.
								// Must be a value greater or equal 1.
								sockets?: int

								// Threads specifies the number of threads inside the vmi.
								// Must be a value greater or equal 1.
								threads?: int
							}

							// Devices allows adding disks, network interfaces, and others
							devices: {
								// Whether to attach the default graphics device or not.
								// VNC will not be available if set to false. Defaults to true.
								autoattachGraphicsDevice?: bool

								// Whether to attach an Input Device.
								// Defaults to false.
								autoattachInputDevice?: bool

								// Whether to attach the Memory balloon device with default
								// period.
								// Period can be adjusted in virt-config.
								// Defaults to true.
								autoattachMemBalloon?: bool

								// Whether to attach a pod network interface. Defaults to true.
								autoattachPodInterface?: bool

								// Whether to attach the default virtio-serial console or not.
								// Serial console access will not be available if set to false.
								// Defaults to true.
								autoattachSerialConsole?: bool

								// Whether to attach the VSOCK CID to the VM or not.
								// VSOCK access will be available if set to true. Defaults to
								// false.
								autoattachVSOCK?: bool

								// Whether or not to enable virtio multi-queue for block devices.
								// Defaults to false.
								blockMultiQueue?: bool

								// To configure and access client devices such as redirecting USB
								clientPassthrough?: {}

								// DisableHotplug disabled the ability to hotplug disks.
								disableHotplug?: bool

								// Disks describes disks, cdroms and luns which are connected to
								// the vmi.
								disks?: list.MaxItems(256) & [...{
									// If specified, the virtual disk will be presented with the given
									// block sizes.
									blockSize?: {
										// CustomBlockSize represents the desired logical and physical
										// block size for a VM disk.
										custom?: {
											logical:  int
											physical: int
										}
										matchVolume?: {
											// Enabled determines if the feature should be enabled or disabled
											// on the guest.
											// Defaults to true.
											enabled?: bool
										}
									}

									// BootOrder is an integer value > 0, used to determine ordering
									// of boot devices.
									// Lower values take precedence.
									// Each disk or interface that has a boot order must have a unique
									// value.
									// Disks without a boot order are not tried if a disk with a boot
									// order exists.
									bootOrder?: int

									// Cache specifies which kvm disk cache mode should be used.
									// Supported values are: CacheNone, CacheWriteThrough.
									cache?: string

									// Attach a volume as a cdrom to the vmi.
									cdrom?: {
										// Bus indicates the type of disk device to emulate.
										// supported values: virtio, sata, scsi.
										bus?: string

										// ReadOnly.
										// Defaults to true.
										readonly?: bool

										// Tray indicates if the tray of the device is open or closed.
										// Allowed values are "open" and "closed".
										// Defaults to closed.
										tray?: string
									}

									// dedicatedIOThread indicates this disk should have an exclusive
									// IO Thread.
									// Enabling this implies useIOThreads = true.
									// Defaults to false.
									dedicatedIOThread?: bool

									// Attach a volume as a disk to the vmi.
									disk?: {
										// Bus indicates the type of disk device to emulate.
										// supported values: virtio, sata, scsi, usb.
										bus?: string

										// If specified, the virtual disk will be placed on the guests pci
										// address with the specified PCI address. For example:
										// 0000:81:01.10
										pciAddress?: string

										// ReadOnly.
										// Defaults to false.
										readonly?: bool
									}

									// If specified, it can change the default error policy (stop) for
									// the disk
									errorPolicy?: string

									// IO specifies which QEMU disk IO mode should be used.
									// Supported values are: native, default, threads.
									io?: string

									// Attach a volume as a LUN to the vmi.
									lun?: {
										// Bus indicates the type of disk device to emulate.
										// supported values: virtio, sata, scsi.
										bus?: string

										// ReadOnly.
										// Defaults to false.
										readonly?: bool

										// Reservation indicates if the disk needs to support the
										// persistent reservation for the SCSI disk
										reservation?: bool
									}

									// Name is the device name
									name: string

									// Serial provides the ability to specify a serial number for the
									// disk device.
									serial?: string

									// If specified the disk is made sharable and multiple write from
									// different VMs are permitted
									shareable?: bool

									// If specified, disk address and its tag will be provided to the
									// guest via config drive metadata
									tag?: string
								}]

								// DownwardMetrics creates a virtio serials for exposing the
								// downward metrics to the vmi.
								downwardMetrics?: {}

								// Filesystems describes filesystem which is connected to the vmi.
								filesystems?: [...{
									// Name is the device name
									name: string

									// Virtiofs is supported
									virtiofs: {}
								}]

								// Whether to attach a GPU device to the vmi.
								gpus?: [...{
									deviceName: string

									// Name of the GPU device as exposed by a device plugin
									name: string

									// If specified, the virtual network interface address and its tag
									// will be provided to the guest via config drive
									tag?: string
									virtualGPUOptions?: {
										display?: {
											// Enabled determines if a display addapter backed by a vGPU
											// should be enabled or disabled on the guest.
											// Defaults to true.
											enabled?: bool
											ramFB?: {
												// Enabled determines if the feature should be enabled or disabled
												// on the guest.
												// Defaults to true.
												enabled?: bool
											}
										}
									}
								}]

								// Whether to attach a host device to the vmi.
								hostDevices?: [...{
									// DeviceName is the resource name of the host device exposed by a
									// device plugin
									deviceName: string
									name:       string

									// If specified, the virtual network interface address and its tag
									// will be provided to the guest via config drive
									tag?: string
								}]

								// Inputs describe input devices
								inputs?: [...{
									// Bus indicates the bus of input device to emulate.
									// Supported values: virtio, usb.
									bus?: string

									// Name is the device name
									name: string

									// Type indicated the type of input device.
									// Supported values: tablet.
									type: string
								}]

								// Interfaces describe network interfaces which are added to the
								// vmi.
								interfaces?: list.MaxItems(256) & [...{
									// If specified, the ACPI index is used to provide network
									// interface device naming, that is stable across changes
									// in PCI addresses assigned to the device.
									// This value is required to be unique across all devices and be
									// between 1 and (16*1024-1).
									acpiIndex?: int
									binding?: {
										// Name references to the binding name as denined in the kubevirt
										// CR.
										// version: 1alphav1
										name: string
									}

									// BootOrder is an integer value > 0, used to determine ordering
									// of boot devices.
									// Lower values take precedence.
									// Each interface or disk that has a boot order must have a unique
									// value.
									// Interfaces without a boot order are not tried.
									bootOrder?: int

									// InterfaceBridge connects to a given network via a linux bridge.
									bridge?: {}

									// If specified the network interface will pass additional DHCP
									// options to the VMI
									dhcpOptions?: {
										// If specified will pass option 67 to interface's DHCP server
										bootFileName?: string

										// If specified will pass the configured NTP server to the VM via
										// DHCP option 042.
										ntpServers?: [...string]

										// If specified will pass extra DHCP options for private use,
										// range: 224-254
										privateOptions?: [...{
											// Option is an Integer value from 224-254
											// Required.
											option: int

											// Value is a String value for the Option provided
											// Required.
											value: string
										}]

										// If specified will pass option 66 to interface's DHCP server
										tftpServerName?: string
									}

									// Interface MAC address. For example: de:ad:00:00:be:af or
									// DE-AD-00-00-BE-AF.
									macAddress?: string

									// DeprecatedMacvtap is an alias to the deprecated Macvtap
									// interface,
									// please refer to Kubevirt user guide for alternatives.
									// Deprecated: Removed in v1.3
									macvtap?: {}

									// InterfaceMasquerade connects to a given network using netfilter
									// rules to nat the traffic.
									masquerade?: {}

									// Interface model.
									// One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio.
									// Defaults to virtio.
									// TODO:(ihar) switch to enums once opengen-api supports them.
									// See: https://github.com/kubernetes/kube-openapi/issues/51
									model?: string

									// Logical name of the interface as well as a reference to the
									// associated networks.
									// Must match the Name of a Network.
									name: string

									// DeprecatedPasst is an alias to the deprecated Passt interface,
									// please refer to Kubevirt user guide for alternatives.
									// Deprecated: Removed in v1.3
									passt?: {}

									// If specified, the virtual network interface will be placed on
									// the guests pci address with the specified PCI address. For
									// example: 0000:81:01.10
									pciAddress?: string

									// List of ports to be forwarded to the virtual machine.
									ports?: [...{
										// If specified, this must be an IANA_SVC_NAME and unique within
										// the pod. Each
										// named port in a pod must have a unique name. Name for the port
										// that can be
										// referred to by services.
										name?: string

										// Number of port to expose for the virtual machine.
										// This must be a valid port number, 0 < x < 65536.
										port: int

										// Protocol for port. Must be UDP or TCP.
										// Defaults to "TCP".
										protocol?: string
									}]

									// DeprecatedSlirp is an alias to the deprecated Slirp interface
									// Deprecated: Removed in v1.3
									slirp?: {}

									// InterfaceSRIOV connects to a given network by passing-through
									// an SR-IOV PCI device via vfio.
									sriov?: {}

									// State represents the requested operational state of the
									// interface.
									// The (only) value supported is 'absent', expressing a request to
									// remove the interface.
									state?: string

									// If specified, the virtual network interface address and its tag
									// will be provided to the guest via config drive
									tag?: string
								}]

								// Whether to log the auto-attached default serial console or not.
								// Serial console logs will be collect to a file and then streamed
								// from a named 'guest-console-log'.
								// Not relevant if autoattachSerialConsole is disabled.
								// Defaults to cluster wide setting on VirtualMachineOptions.
								logSerialConsole?: bool

								// If specified, virtual network interfaces configured with a
								// virtio bus will also enable the vhost multiqueue feature for
								// network devices. The number of queues created depends on
								// additional factors of the VirtualMachineInstance, like the
								// number of guest CPUs.
								networkInterfaceMultiqueue?: bool

								// Whether to have random number generator from host
								rng?: {}

								// Whether to emulate a sound device.
								sound?: {
									// We only support ich9 or ac97.
									// If SoundDevice is not set: No sound card is emulated.
									// If SoundDevice is set but Model is not: ich9
									model?: string

									// User's defined name for this sound device
									name: string
								}
								tpm?: {
									// Persistent indicates the state of the TPM device should be kept
									// accross reboots
									// Defaults to false
									persistent?: bool
								}

								// Fall back to legacy virtio 0.9 support if virtio bus is
								// selected on devices.
								// This is helpful for old machines like CentOS6 or RHEL6 which
								// do not understand virtio_non_transitional (virtio 1.0).
								useVirtioTransitional?: bool

								// Watchdog describes a watchdog device which can be added to the
								// vmi.
								watchdog?: {
									i6300esb?: {
										// The action to take. Valid values are poweroff, reset, shutdown.
										// Defaults to reset.
										action?: string
									}

									// Name of the watchdog.
									name: string
								}
							}

							// Features like acpi, apic, hyperv, smm.
							features?: {
								acpi?: {
									// Enabled determines if the feature should be enabled or disabled
									// on the guest.
									// Defaults to true.
									enabled?: bool
								}

								// Defaults to the machine type setting.
								apic?: {
									// Enabled determines if the feature should be enabled or disabled
									// on the guest.
									// Defaults to true.
									enabled?: bool

									// EndOfInterrupt enables the end of interrupt notification in the
									// guest.
									// Defaults to false.
									endOfInterrupt?: bool
								}

								// Defaults to the machine type setting.
								hyperv?: {
									evmcs?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									frequencies?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									ipi?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									reenlightenment?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									relaxed?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									reset?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									runtime?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}

									// Spinlocks allows to configure the spinlock retry attempts.
									spinlocks?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool

										// Retries indicates the number of retries.
										// Must be a value greater or equal 4096.
										// Defaults to 4096.
										spinlocks?: int
									}
									synic?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}

									// SyNICTimer enables Synthetic Interrupt Controller Timers,
									// reducing CPU load.
									// Defaults to the machine type setting.
									synictimer?: {
										direct?: {
											// Enabled determines if the feature should be enabled or disabled
											// on the guest.
											// Defaults to true.
											enabled?: bool
										}
										enabled?: bool
									}
									tlbflush?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
									vapic?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}

									// VendorID allows setting the hypervisor vendor id.
									// Defaults to the machine type setting.
									vendorid?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool

										// VendorID sets the hypervisor vendor id, visible to the vmi.
										// String up to twelve characters.
										vendorid?: string
									}
									vpindex?: {
										// Enabled determines if the feature should be enabled or disabled
										// on the guest.
										// Defaults to true.
										enabled?: bool
									}
								}
								hypervPassthrough?: {
									enabled?: bool
								}
								kvm?: {
									// Hide the KVM hypervisor from standard MSR based discovery.
									// Defaults to false
									hidden?: bool
								}
								pvspinlock?: {
									// Enabled determines if the feature should be enabled or disabled
									// on the guest.
									// Defaults to true.
									enabled?: bool
								}
								smm?: {
									// Enabled determines if the feature should be enabled or disabled
									// on the guest.
									// Defaults to true.
									enabled?: bool
								}
							}

							// Firmware.
							firmware?: {
								acpi?: {
									// SlicNameRef should match the volume name of a secret object.
									// The data in the secret should
									// be a binary blob that follows the ACPI SLIC standard, see:
									// https://learn.microsoft.com/en-us/previous-versions/windows/hardware/design/dn653305(v=vs.85)
									slicNameRef?: string
								}

								// Settings to control the bootloader that is used.
								bootloader?: {
									bios?: {
										// If set, the BIOS output will be transmitted over serial
										useSerial?: bool
									}

									// If set, EFI will be used instead of BIOS.
									efi?: {
										// If set to true, Persistent will persist the EFI NVRAM across
										// reboots.
										// Defaults to false
										persistent?: bool

										// If set, SecureBoot will be enabled and the OVMF roms will be
										// swapped for
										// SecureBoot-enabled ones.
										// Requires SMM to be enabled.
										// Defaults to true
										secureBoot?: bool
									}
								}

								// Settings to set the kernel for booting.
								kernelBoot?: {
									// Container defines the container that containes kernel artifacts
									container?: {
										// Image that contains initrd / kernel files.
										image: string

										// Image pull policy.
										// One of Always, Never, IfNotPresent.
										// Defaults to Always if :latest tag is specified, or IfNotPresent
										// otherwise.
										// Cannot be updated.
										// More info:
										// https://kubernetes.io/docs/concepts/containers/images#updating-images
										imagePullPolicy?: string

										// ImagePullSecret is the name of the Docker registry secret
										// required to pull the image. The secret must already exist.
										imagePullSecret?: string

										// the fully-qualified path to the ramdisk image in the host OS
										initrdPath?: string

										// The fully-qualified path to the kernel image in the host OS
										kernelPath?: string
									}

									// Arguments to be passed to the kernel at boot time
									kernelArgs?: string
								}

								// The system-serial-number in SMBIOS
								serial?: string

								// UUID reported by the vmi bios.
								// Defaults to a random generated uid.
								uuid?: string
							}

							// Controls whether or not disks will share IOThreads.
							// Omitting IOThreadsPolicy disables use of IOThreads.
							// One of: shared, auto
							ioThreadsPolicy?: string
							launchSecurity?: {
								// AMD Secure Encrypted Virtualization (SEV).
								sev?: {
									// If specified, run the attestation process for a vmi.
									attestation?: {}

									// Base64 encoded guest owner's Diffie-Hellman key.
									dhCert?: string
									policy?: {
										// SEV-ES is required.
										// Defaults to false.
										encryptedState?: bool
									}

									// Base64 encoded session blob.
									session?: string
								}
							}
							machine?: {
								// QEMU machine type is the actual chipset of the
								// VirtualMachineInstance.
								type?: string
							}

							// Memory allow specifying the VMI memory features.
							memory?: {
								// Guest allows to specifying the amount of memory which is
								// visible inside the Guest OS.
								// The Guest must lie between Requests and Limits from the
								// resources section.
								// Defaults to the requested memory in the resources section if
								// not specified.
								guest?: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
								hugepages?: {
									// PageSize specifies the hugepage size, for x86_64 architecture
									// valid values are 1Gi and 2Mi.
									pageSize?: string
								}

								// MaxGuest allows to specify the maximum amount of memory which
								// is visible inside the Guest OS.
								// The delta between MaxGuest and Guest is the amount of memory
								// that can be hot(un)plugged.
								maxGuest?: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
							}

							// Resources describes the Compute Resources required by this vmi.
							resources?: {
								// Limits describes the maximum amount of compute resources
								// allowed.
								// Valid resource keys are "memory" and "cpu".
								limits?: {
									[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// Don't ask the scheduler to take the guest-management overhead
								// into account. Instead
								// put the overhead only into the container's memory limit. This
								// can lead to crashes if
								// all memory is in use on a node. Defaults to false.
								overcommitGuestOverhead?: bool

								// Requests is a description of the initial vmi resources.
								// Valid resource keys are "memory" and "cpu".
								requests?: {
									[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
							}
						}

						// EvictionStrategy describes the strategy to follow when a node
						// drain occurs.
						// The possible options are:
						// - "None": No action will be taken, according to the specified
						// 'RunStrategy' the VirtualMachine will be restarted or
						// shutdown.
						// - "LiveMigrate": the VirtualMachineInstance will be migrated
						// instead of being shutdown.
						// - "LiveMigrateIfPossible": the same as "LiveMigrate" but only
						// if the VirtualMachine is Live-Migratable, otherwise it will
						// behave as "None".
						// - "External": the VirtualMachineInstance will be protected by a
						// PDB and 'vmi.Status.EvacuationNodeName' will be set on
						// eviction. This is mainly useful for
						// cluster-api-provider-kubevirt (capk) which needs a way for
						// VMI's to be blocked from eviction, yet signal capk that
						// eviction has been called on the VMI so the capk controller can
						// handle tearing the VMI down. Details can be found in the
						// commit description
						// https://github.com/kubevirt/kubevirt/commit/c1d77face705c8b126696bac9a3ee3825f27f1fa.
						evictionStrategy?: string

						// Specifies the hostname of the vmi
						// If not specified, the hostname will be set to the name of the
						// vmi, if dhcp or cloud-init is configured properly.
						hostname?: string

						// Periodic probe of VirtualMachineInstance liveness.
						// VirtualmachineInstances will be stopped if the probe fails.
						// Cannot be updated.
						// More info:
						// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
						livenessProbe?: {
							exec?: {
								// Command is the command line to execute inside the container,
								// the working directory for the
								// command is root ('/') in the container's filesystem. The
								// command is simply exec'd, it is
								// not run inside a shell, so traditional shell instructions ('|',
								// etc) won't work. To use
								// a shell, you need to explicitly call out to that shell.
								// Exit status of 0 is treated as live/healthy and non-zero is
								// unhealthy.
								command?: [...string]
							}

							// Minimum consecutive failures for the probe to be considered
							// failed after having succeeded.
							// Defaults to 3. Minimum value is 1.
							failureThreshold?: int

							// GuestAgentPing contacts the qemu-guest-agent for availability
							// checks.
							guestAgentPing?: {}

							// HTTPGet specifies the http request to perform.
							httpGet?: {
								// Host name to connect to, defaults to the pod IP. You probably
								// want to set
								// "Host" in httpHeaders instead.
								host?: string

								// Custom headers to set in the request. HTTP allows repeated
								// headers.
								httpHeaders?: [...{
									// The header field name.
									// This will be canonicalized upon output, so case-variant names
									// will be understood as the same header.
									name: string

									// The header field value
									value: string
								}]

								// Path to access on the HTTP server.
								path?: string

								// Name or number of the port to access on the container.
								// Number must be in the range 1 to 65535.
								// Name must be an IANA_SVC_NAME.
								port: (int | string) & {
									string
								}

								// Scheme to use for connecting to the host.
								// Defaults to HTTP.
								scheme?: string
							}

							// Number of seconds after the VirtualMachineInstance has started
							// before liveness probes are initiated.
							// More info:
							// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
							initialDelaySeconds?: int

							// How often (in seconds) to perform the probe.
							// Default to 10 seconds. Minimum value is 1.
							periodSeconds?: int

							// Minimum consecutive successes for the probe to be considered
							// successful after having failed.
							// Defaults to 1. Must be 1 for liveness. Minimum value is 1.
							successThreshold?: int

							// TCPSocket specifies an action involving a TCP port.
							// TCP hooks not yet supported
							// TODO: implement a realistic TCP lifecycle hook
							tcpSocket?: {
								// Optional: Host name to connect to, defaults to the pod IP.
								host?: string

								// Number or name of the port to access on the container.
								// Number must be in the range 1 to 65535.
								// Name must be an IANA_SVC_NAME.
								port: (int | string) & {
									string
								}
							}

							// Number of seconds after which the probe times out.
							// For exec probes the timeout fails the probe but does not
							// terminate the command running on the guest.
							// This means a blocking command can result in an increasing load
							// on the guest.
							// A small buffer will be added to the resulting workload exec
							// probe to compensate for delays
							// caused by the qemu guest exec mechanism.
							// Defaults to 1 second. Minimum value is 1.
							// More info:
							// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
							timeoutSeconds?: int
						}

						// List of networks that can be attached to a vm's virtual
						// interface.
						networks?: list.MaxItems(256) & [...{
							// Represents the multus cni network.
							multus?: {
								// Select the default network and add it to the
								// multus-cni.io/default-network annotation.
								default?: bool

								// References to a NetworkAttachmentDefinition CRD object. Format:
								// <networkName>, <namespace>/<networkName>. If namespace is not
								// specified, VMI namespace is assumed.
								networkName: string
							}

							// Network name.
							// Must be a DNS_LABEL and unique within the vm.
							// More info:
							// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
							name: string

							// Represents the stock pod network interface.
							pod?: {
								// IPv6 CIDR for the vm network.
								// Defaults to fd10:0:2::/120 if not specified.
								vmIPv6NetworkCIDR?: string

								// CIDR for vm network.
								// Default 10.0.2.0/24 if not specified.
								vmNetworkCIDR?: string
							}
						}]

						// NodeSelector is a selector which must be true for the vmi to
						// fit on a node.
						// Selector which must match a node's labels for the vmi to be
						// scheduled on that node.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
						nodeSelector?: {
							[string]: string
						}

						// If specified, indicates the pod's priority.
						// If not specified, the pod priority will be default or zero if
						// there is no
						// default.
						priorityClassName?: string

						// Periodic probe of VirtualMachineInstance service readiness.
						// VirtualmachineInstances will be removed from service endpoints
						// if the probe fails.
						// Cannot be updated.
						// More info:
						// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
						readinessProbe?: {
							exec?: {
								// Command is the command line to execute inside the container,
								// the working directory for the
								// command is root ('/') in the container's filesystem. The
								// command is simply exec'd, it is
								// not run inside a shell, so traditional shell instructions ('|',
								// etc) won't work. To use
								// a shell, you need to explicitly call out to that shell.
								// Exit status of 0 is treated as live/healthy and non-zero is
								// unhealthy.
								command?: [...string]
							}

							// Minimum consecutive failures for the probe to be considered
							// failed after having succeeded.
							// Defaults to 3. Minimum value is 1.
							failureThreshold?: int

							// GuestAgentPing contacts the qemu-guest-agent for availability
							// checks.
							guestAgentPing?: {}

							// HTTPGet specifies the http request to perform.
							httpGet?: {
								// Host name to connect to, defaults to the pod IP. You probably
								// want to set
								// "Host" in httpHeaders instead.
								host?: string

								// Custom headers to set in the request. HTTP allows repeated
								// headers.
								httpHeaders?: [...{
									// The header field name.
									// This will be canonicalized upon output, so case-variant names
									// will be understood as the same header.
									name: string

									// The header field value
									value: string
								}]

								// Path to access on the HTTP server.
								path?: string

								// Name or number of the port to access on the container.
								// Number must be in the range 1 to 65535.
								// Name must be an IANA_SVC_NAME.
								port: (int | string) & {
									string
								}

								// Scheme to use for connecting to the host.
								// Defaults to HTTP.
								scheme?: string
							}

							// Number of seconds after the VirtualMachineInstance has started
							// before liveness probes are initiated.
							// More info:
							// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
							initialDelaySeconds?: int

							// How often (in seconds) to perform the probe.
							// Default to 10 seconds. Minimum value is 1.
							periodSeconds?: int

							// Minimum consecutive successes for the probe to be considered
							// successful after having failed.
							// Defaults to 1. Must be 1 for liveness. Minimum value is 1.
							successThreshold?: int

							// TCPSocket specifies an action involving a TCP port.
							// TCP hooks not yet supported
							// TODO: implement a realistic TCP lifecycle hook
							tcpSocket?: {
								// Optional: Host name to connect to, defaults to the pod IP.
								host?: string

								// Number or name of the port to access on the container.
								// Number must be in the range 1 to 65535.
								// Name must be an IANA_SVC_NAME.
								port: (int | string) & {
									string
								}
							}

							// Number of seconds after which the probe times out.
							// For exec probes the timeout fails the probe but does not
							// terminate the command running on the guest.
							// This means a blocking command can result in an increasing load
							// on the guest.
							// A small buffer will be added to the resulting workload exec
							// probe to compensate for delays
							// caused by the qemu guest exec mechanism.
							// Defaults to 1 second. Minimum value is 1.
							// More info:
							// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
							timeoutSeconds?: int
						}

						// If specified, the VMI will be dispatched by specified
						// scheduler.
						// If not specified, the VMI will be dispatched by default
						// scheduler.
						schedulerName?: string

						// StartStrategy can be set to "Paused" if Virtual Machine should
						// be started in paused state.
						startStrategy?: string

						// If specified, the fully qualified vmi hostname will be
						// "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
						// If not specified, the vmi will not have a domainname at all.
						// The DNS entry will resolve to the vmi,
						// no matter if the vmi itself can pick up a hostname.
						subdomain?: string

						// Grace period observed after signalling a VirtualMachineInstance
						// to stop after which the VirtualMachineInstance is force
						// terminated.
						terminationGracePeriodSeconds?: int

						// If toleration is specified, obey all the toleration rules.
						tolerations?: [...{
							// Effect indicates the taint effect to match. Empty means match
							// all taint effects.
							// When specified, allowed values are NoSchedule, PreferNoSchedule
							// and NoExecute.
							effect?: string

							// Key is the taint key that the toleration applies to. Empty
							// means match all taint keys.
							// If the key is empty, operator must be Exists; this combination
							// means to match all values and all keys.
							key?: string

							// Operator represents a key's relationship to the value.
							// Valid operators are Exists and Equal. Defaults to Equal.
							// Exists is equivalent to wildcard for value, so that a pod can
							// tolerate all taints of a particular category.
							operator?: string

							// TolerationSeconds represents the period of time the toleration
							// (which must be
							// of effect NoExecute, otherwise this field is ignored) tolerates
							// the taint. By default,
							// it is not set, which means tolerate the taint forever (do not
							// evict). Zero and
							// negative values will be treated as 0 (evict immediately) by the
							// system.
							tolerationSeconds?: int

							// Value is the taint value the toleration matches to.
							// If the operator is Exists, the value should be empty, otherwise
							// just a regular string.
							value?: string
						}]

						// TopologySpreadConstraints describes how a group of VMIs will be
						// spread across a given topology
						// domains. K8s scheduler will schedule VMI pods in a way which
						// abides by the constraints.
						topologySpreadConstraints?: [...{
							// LabelSelector is used to find matching pods.
							// Pods that match this label selector are counted to determine
							// the number of pods
							// in their corresponding topology domain.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select the pods
							// over which
							// spreading will be calculated. The keys are used to lookup
							// values from the
							// incoming pod labels, those key-value labels are ANDed with
							// labelSelector
							// to select the group of existing pods over which spreading will
							// be calculated
							// for the incoming pod. The same key is forbidden to exist in
							// both MatchLabelKeys and LabelSelector.
							// MatchLabelKeys cannot be set when LabelSelector isn't set.
							// Keys that don't exist in the incoming pod labels will
							// be ignored. A null or empty list means only match against
							// labelSelector.
							//
							//
							// This is a beta field and requires the
							// MatchLabelKeysInPodTopologySpread feature gate to be enabled
							// (enabled by default).
							matchLabelKeys?: [...string]

							// MaxSkew describes the degree to which pods may be unevenly
							// distributed.
							// When 'whenUnsatisfiable=DoNotSchedule', it is the maximum
							// permitted difference
							// between the number of matching pods in the target topology and
							// the global minimum.
							// The global minimum is the minimum number of matching pods in an
							// eligible domain
							// or zero if the number of eligible domains is less than
							// MinDomains.
							// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
							// with the same
							// labelSelector spread as 2/2/1:
							// In this case, the global minimum is 1.
							// | zone1 | zone2 | zone3 |
							// | P P | P P | P |
							// - if MaxSkew is 1, incoming pod can only be scheduled to zone3
							// to become 2/2/2;
							// scheduling it onto zone1(zone2) would make the ActualSkew(3-1)
							// on zone1(zone2)
							// violate MaxSkew(1).
							// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
							// When 'whenUnsatisfiable=ScheduleAnyway', it is used to give
							// higher precedence
							// to topologies that satisfy it.
							// It's a required field. Default value is 1 and 0 is not allowed.
							maxSkew: int

							// MinDomains indicates a minimum number of eligible domains.
							// When the number of eligible domains with matching topology keys
							// is less than minDomains,
							// Pod Topology Spread treats "global minimum" as 0, and then the
							// calculation of Skew is performed.
							// And when the number of eligible domains with matching topology
							// keys equals or greater than minDomains,
							// this value has no effect on scheduling.
							// As a result, when the number of eligible domains is less than
							// minDomains,
							// scheduler won't schedule more than maxSkew Pods to those
							// domains.
							// If value is nil, the constraint behaves as if MinDomains is
							// equal to 1.
							// Valid values are integers greater than 0.
							// When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
							//
							//
							// For example, in a 3-zone cluster, MaxSkew is set to 2,
							// MinDomains is set to 5 and pods with the same
							// labelSelector spread as 2/2/2:
							// | zone1 | zone2 | zone3 |
							// | P P | P P | P P |
							// The number of domains is less than 5(MinDomains), so "global
							// minimum" is treated as 0.
							// In this situation, new pod with the same labelSelector cannot
							// be scheduled,
							// because computed skew will be 3(3 - 0) if new Pod is scheduled
							// to any of the three zones,
							// it will violate MaxSkew.
							minDomains?: int

							// NodeAffinityPolicy indicates how we will treat Pod's
							// nodeAffinity/nodeSelector
							// when calculating pod topology spread skew. Options are:
							// - Honor: only nodes matching nodeAffinity/nodeSelector are
							// included in the calculations.
							// - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are
							// included in the calculations.
							//
							//
							// If this value is nil, the behavior is equivalent to the Honor
							// policy.
							// This is a beta-level feature default enabled by the
							// NodeInclusionPolicyInPodTopologySpread feature flag.
							nodeAffinityPolicy?: string

							// NodeTaintsPolicy indicates how we will treat node taints when
							// calculating
							// pod topology spread skew. Options are:
							// - Honor: nodes without taints, along with tainted nodes for
							// which the incoming pod
							// has a toleration, are included.
							// - Ignore: node taints are ignored. All nodes are included.
							//
							//
							// If this value is nil, the behavior is equivalent to the Ignore
							// policy.
							// This is a beta-level feature default enabled by the
							// NodeInclusionPolicyInPodTopologySpread feature flag.
							nodeTaintsPolicy?: string

							// TopologyKey is the key of node labels. Nodes that have a label
							// with this key
							// and identical values are considered to be in the same topology.
							// We consider each <key, value> as a "bucket", and try to put
							// balanced number
							// of pods into each bucket.
							// We define a domain as a particular instance of a topology.
							// Also, we define an eligible domain as a domain whose nodes meet
							// the requirements of
							// nodeAffinityPolicy and nodeTaintsPolicy.
							// e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a
							// domain of that topology.
							// And, if TopologyKey is "topology.kubernetes.io/zone", each zone
							// is a domain of that topology.
							// It's a required field.
							topologyKey: string

							// WhenUnsatisfiable indicates how to deal with a pod if it
							// doesn't satisfy
							// the spread constraint.
							// - DoNotSchedule (default) tells the scheduler not to schedule
							// it.
							// - ScheduleAnyway tells the scheduler to schedule the pod in any
							// location,
							// but giving higher precedence to topologies that would help
							// reduce the
							// skew.
							// A constraint is considered "Unsatisfiable" for an incoming pod
							// if and only if every possible node assignment for that pod
							// would violate
							// "MaxSkew" on some topology.
							// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
							// with the same
							// labelSelector spread as 3/1/1:
							// | zone1 | zone2 | zone3 |
							// | P P P | P | P |
							// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
							// only be scheduled
							// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on
							// zone2(zone3) satisfies
							// MaxSkew(1). In other words, the cluster can still be
							// imbalanced, but scheduler
							// won't make it *more* imbalanced.
							// It's a required field.
							whenUnsatisfiable: string
						}]

						// List of volumes that can be mounted by disks belonging to the
						// vmi.
						volumes?: list.MaxItems(256) & [...{
							// CloudInitConfigDrive represents a cloud-init Config Drive
							// user-data source.
							// The Config Drive data will be added as a disk to the vmi. A
							// proper cloud-init installation is required inside the guest.
							// More info:
							// https://cloudinit.readthedocs.io/en/latest/topics/datasources/configdrive.html
							cloudInitConfigDrive?: {
								// NetworkData contains config drive inline cloud-init
								// networkdata.
								networkData?: string

								// NetworkDataBase64 contains config drive cloud-init networkdata
								// as a base64 encoded string.
								networkDataBase64?: string
								networkDataSecretRef?: {
									// Name of the referent.
									// More info:
									// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
									// TODO: Add other useful fields. apiVersion, kind, uid?
									name?: string
								}
								secretRef?: {
									// Name of the referent.
									// More info:
									// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
									// TODO: Add other useful fields. apiVersion, kind, uid?
									name?: string
								}

								// UserData contains config drive inline cloud-init userdata.
								userData?: string

								// UserDataBase64 contains config drive cloud-init userdata as a
								// base64 encoded string.
								userDataBase64?: string
							}

							// CloudInitNoCloud represents a cloud-init NoCloud user-data
							// source.
							// The NoCloud data will be added as a disk to the vmi. A proper
							// cloud-init installation is required inside the guest.
							// More info:
							// http://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html
							cloudInitNoCloud?: {
								// NetworkData contains NoCloud inline cloud-init networkdata.
								networkData?: string

								// NetworkDataBase64 contains NoCloud cloud-init networkdata as a
								// base64 encoded string.
								networkDataBase64?: string
								networkDataSecretRef?: {
									// Name of the referent.
									// More info:
									// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
									// TODO: Add other useful fields. apiVersion, kind, uid?
									name?: string
								}
								secretRef?: {
									// Name of the referent.
									// More info:
									// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
									// TODO: Add other useful fields. apiVersion, kind, uid?
									name?: string
								}

								// UserData contains NoCloud inline cloud-init userdata.
								userData?: string

								// UserDataBase64 contains NoCloud cloud-init userdata as a base64
								// encoded string.
								userDataBase64?: string
							}

							// ConfigMapSource represents a reference to a ConfigMap in the
							// same namespace.
							// More info:
							// https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
							configMap?: {
								// Name of the referent.
								// More info:
								// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
								// TODO: Add other useful fields. apiVersion, kind, uid?
								name?: string

								// Specify whether the ConfigMap or it's keys must be defined
								optional?: bool

								// The volume label of the resulting disk inside the VMI.
								// Different bootstrapping mechanisms require different values.
								// Typical values are "cidata" (cloud-init), "config-2"
								// (cloud-init) or "OEMDRV" (kickstart).
								volumeLabel?: string
							}

							// ContainerDisk references a docker image, embedding a qcow or
							// raw disk.
							// More info:
							// https://kubevirt.gitbooks.io/user-guide/registry-disk.html
							containerDisk?: {
								// Image is the name of the image with the embedded disk.
								image: string

								// Image pull policy.
								// One of Always, Never, IfNotPresent.
								// Defaults to Always if :latest tag is specified, or IfNotPresent
								// otherwise.
								// Cannot be updated.
								// More info:
								// https://kubernetes.io/docs/concepts/containers/images#updating-images
								imagePullPolicy?: string

								// ImagePullSecret is the name of the Docker registry secret
								// required to pull the image. The secret must already exist.
								imagePullSecret?: string

								// Path defines the path to disk file in the container
								path?: string
							}

							// DataVolume represents the dynamic creation a PVC for this
							// volume as well as
							// the process of populating that PVC with a disk image.
							dataVolume?: {
								// Hotpluggable indicates whether the volume can be hotplugged and
								// hotunplugged.
								hotpluggable?: bool

								// Name of both the DataVolume and the PVC in the same namespace.
								// After PVC population the DataVolume is garbage collected by
								// default.
								name: string
							}

							// DownwardAPI represents downward API about the pod that should
							// populate this volume
							downwardAPI?: {
								// Fields is a list of downward API volume file
								fields?: [...{
									// Required: Selects a field of the pod: only annotations, labels,
									// name, namespace and uid are supported.
									fieldRef?: {
										// Version of the schema the FieldPath is written in terms of,
										// defaults to "v1".
										apiVersion?: string

										// Path of the field to select in the specified API version.
										fieldPath: string
									}

									// Optional: mode bits used to set permissions on this file, must
									// be an octal value
									// between 0000 and 0777 or a decimal value between 0 and 511.
									// YAML accepts both octal and decimal values, JSON requires
									// decimal values for mode bits.
									// If not specified, the volume defaultMode will be used.
									// This might be in conflict with other options that affect the
									// file
									// mode, like fsGroup, and the result can be other mode bits set.
									mode?: int

									// Required: Path is the relative path name of the file to be
									// created. Must not be absolute or contain the '..' path. Must
									// be utf-8 encoded. The first item of the relative path must not
									// start with '..'
									path: string

									// Selects a resource of the container: only resources limits and
									// requests
									// (limits.cpu, limits.memory, requests.cpu and requests.memory)
									// are currently supported.
									resourceFieldRef?: {
										// Container name: required for volumes, optional for env vars
										containerName?: string

										// Specifies the output format of the exposed resources, defaults
										// to "1"
										divisor?: (int | string) & {
											=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
										}

										// Required: resource to select
										resource: string
									}
								}]

								// The volume label of the resulting disk inside the VMI.
								// Different bootstrapping mechanisms require different values.
								// Typical values are "cidata" (cloud-init), "config-2"
								// (cloud-init) or "OEMDRV" (kickstart).
								volumeLabel?: string
							}

							// DownwardMetrics adds a very small disk to VMIs which contains a
							// limited view of host and guest
							// metrics. The disk content is compatible with vhostmd
							// (https://github.com/vhostmd/vhostmd) and vm-dump-metrics.
							downwardMetrics?: {}
							emptyDisk?: {
								// Capacity of the sparse disk.
								capacity: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
							}
							ephemeral?: {
								// PersistentVolumeClaimVolumeSource represents a reference to a
								// PersistentVolumeClaim in the same namespace.
								// Directly attached to the vmi via qemu.
								// More info:
								// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
								persistentVolumeClaim?: {
									// claimName is the name of a PersistentVolumeClaim in the same
									// namespace as the pod using this volume.
									// More info:
									// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
									claimName: string

									// readOnly Will force the ReadOnly setting in VolumeMounts.
									// Default false.
									readOnly?: bool
								}
							}

							// HostDisk represents a disk created on the cluster level
							hostDisk?: {
								// Capacity of the sparse disk
								capacity?: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// The path to HostDisk image located on the cluster
								path: string

								// Shared indicate whether the path is shared between nodes
								shared?: bool

								// Contains information if disk.img exists or should be created
								// allowed options are 'Disk' and 'DiskOrCreate'
								type: string
							}

							// MemoryDump is attached to the virt launcher and is populated
							// with a memory dump of the vmi
							memoryDump?: {
								// claimName is the name of a PersistentVolumeClaim in the same
								// namespace as the pod using this volume.
								// More info:
								// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
								claimName: string

								// Hotpluggable indicates whether the volume can be hotplugged and
								// hotunplugged.
								hotpluggable?: bool

								// readOnly Will force the ReadOnly setting in VolumeMounts.
								// Default false.
								readOnly?: bool
							}

							// Volume's name.
							// Must be a DNS_LABEL and unique within the vmi.
							// More info:
							// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
							name: string

							// PersistentVolumeClaimVolumeSource represents a reference to a
							// PersistentVolumeClaim in the same namespace.
							// Directly attached to the vmi via qemu.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
							persistentVolumeClaim?: {
								// claimName is the name of a PersistentVolumeClaim in the same
								// namespace as the pod using this volume.
								// More info:
								// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
								claimName: string

								// Hotpluggable indicates whether the volume can be hotplugged and
								// hotunplugged.
								hotpluggable?: bool

								// readOnly Will force the ReadOnly setting in VolumeMounts.
								// Default false.
								readOnly?: bool
							}

							// SecretVolumeSource represents a reference to a secret data in
							// the same namespace.
							// More info:
							// https://kubernetes.io/docs/concepts/configuration/secret/
							secret?: {
								// Specify whether the Secret or it's keys must be defined
								optional?: bool

								// Name of the secret in the pod's namespace to use.
								// More info:
								// https://kubernetes.io/docs/concepts/storage/volumes#secret
								secretName?: string

								// The volume label of the resulting disk inside the VMI.
								// Different bootstrapping mechanisms require different values.
								// Typical values are "cidata" (cloud-init), "config-2"
								// (cloud-init) or "OEMDRV" (kickstart).
								volumeLabel?: string
							}
							serviceAccount?: {
								// Name of the service account in the pod's namespace to use.
								// More info:
								// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
								serviceAccountName?: string
							}

							// Represents a Sysprep volume source.
							sysprep?: {
								configMap?: {
									// Name of the referent.
									// More info:
									// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
									// TODO: Add other useful fields. apiVersion, kind, uid?
									name?: string
								}
								secret?: {
									// Name of the referent.
									// More info:
									// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
									// TODO: Add other useful fields. apiVersion, kind, uid?
									name?: string
								}
							}
						}]
					}
				}

				// UpdateVolumesStrategy is the strategy to apply on volumes
				// updates
				updateVolumesStrategy?: string
			}

			// Status holds the current state of the controller and brief
			// information
			// about its associated VirtualMachineInstance
			status?: {
				// Hold the state information of the VirtualMachine and its
				// VirtualMachineInstance
				conditions?: [...{
					lastProbeTime?:      null | string
					lastTransitionTime?: null | string
					message?:            string
					reason?:             string
					status:              string
					type:                string
				}]

				// Created indicates if the virtual machine is created in the
				// cluster
				created?: bool

				// DesiredGeneration is the generation which is desired for the
				// VMI.
				// This will be used in comparisons with ObservedGeneration to
				// understand when
				// the VMI is out of sync. This will be changed at the same time
				// as
				// ObservedGeneration to remove errors which could occur if
				// Generation is
				// updated through an Update() before ObservedGeneration in
				// Status.
				desiredGeneration?: int

				// MemoryDumpRequest tracks memory dump request phase and info of
				// getting a memory
				// dump to the given pvc
				memoryDumpRequest?: null | {
					// ClaimName is the name of the pvc that will contain the memory
					// dump
					claimName: string

					// EndTimestamp represents the time the memory dump was completed
					endTimestamp?: string

					// FileName represents the name of the output file
					fileName?: string

					// Message is a detailed message about failure of the memory dump
					message?: string

					// Phase represents the memory dump phase
					phase: string

					// Remove represents request of dissociating the memory dump pvc
					remove?: bool

					// StartTimestamp represents the time the memory dump started
					startTimestamp?: string
				}

				// ObservedGeneration is the generation observed by the vmi when
				// started.
				observedGeneration?: int

				// PrintableStatus is a human readable, high-level representation
				// of the status of the virtual machine
				printableStatus?: string | *"Stopped"

				// Ready indicates if the virtual machine is running and ready
				ready?: bool

				// RestoreInProgress is the name of the VirtualMachineRestore
				// currently executing
				restoreInProgress?: string

				// RunStrategy tracks the last recorded RunStrategy used by the
				// VM.
				// This is needed to correctly process the next strategy (for now
				// only the RerunOnFailure)
				runStrategy?: string

				// SnapshotInProgress is the name of the VirtualMachineSnapshot
				// currently executing
				snapshotInProgress?: string

				// StartFailure tracks consecutive VMI startup failures for the
				// purposes of
				// crash loop backoffs
				startFailure?: null | {
					consecutiveFailCount?: int

					// UID is a type that holds unique ID values, including UUIDs.
					// Because we
					// don't ONLY use UUIDs, this is an alias to string. Being a type
					// captures
					// intent and helps make sure that UIDs and names do not get
					// conflated.
					lastFailedVMIUID?:    string
					retryAfterTimestamp?: string
				}

				// StateChangeRequests indicates a list of actions that should be
				// taken on a VMI
				// e.g. stop a specific VMI then start a new one.
				stateChangeRequests?: [...{
					// Indicates the type of action that is requested. e.g. Start or
					// Stop
					action: string

					// Provides additional data in order to perform the Action
					data?: {
						[string]: string
					}

					// Indicates the UUID of an existing Virtual Machine Instance that
					// this change request applies to -- if applicable
					uid?: string
				}]

				// VolumeRequests indicates a list of volumes add or remove from
				// the VMI template and
				// hotplug on an active running VMI.
				volumeRequests?: [...{
					// AddVolumeOptions when set indicates a volume should be added.
					// The details
					// within this field specify how to add the volume
					addVolumeOptions?: {
						// Disk represents the hotplug disk that will be plugged into the
						// running VMI
						disk: {
							// If specified, the virtual disk will be presented with the given
							// block sizes.
							blockSize?: {
								// CustomBlockSize represents the desired logical and physical
								// block size for a VM disk.
								custom?: {
									logical:  int
									physical: int
								}
								matchVolume?: {
									// Enabled determines if the feature should be enabled or disabled
									// on the guest.
									// Defaults to true.
									enabled?: bool
								}
							}

							// BootOrder is an integer value > 0, used to determine ordering
							// of boot devices.
							// Lower values take precedence.
							// Each disk or interface that has a boot order must have a unique
							// value.
							// Disks without a boot order are not tried if a disk with a boot
							// order exists.
							bootOrder?: int

							// Cache specifies which kvm disk cache mode should be used.
							// Supported values are: CacheNone, CacheWriteThrough.
							cache?: string

							// Attach a volume as a cdrom to the vmi.
							cdrom?: {
								// Bus indicates the type of disk device to emulate.
								// supported values: virtio, sata, scsi.
								bus?: string

								// ReadOnly.
								// Defaults to true.
								readonly?: bool

								// Tray indicates if the tray of the device is open or closed.
								// Allowed values are "open" and "closed".
								// Defaults to closed.
								tray?: string
							}

							// dedicatedIOThread indicates this disk should have an exclusive
							// IO Thread.
							// Enabling this implies useIOThreads = true.
							// Defaults to false.
							dedicatedIOThread?: bool

							// Attach a volume as a disk to the vmi.
							disk?: {
								// Bus indicates the type of disk device to emulate.
								// supported values: virtio, sata, scsi, usb.
								bus?: string

								// If specified, the virtual disk will be placed on the guests pci
								// address with the specified PCI address. For example:
								// 0000:81:01.10
								pciAddress?: string

								// ReadOnly.
								// Defaults to false.
								readonly?: bool
							}

							// If specified, it can change the default error policy (stop) for
							// the disk
							errorPolicy?: string

							// IO specifies which QEMU disk IO mode should be used.
							// Supported values are: native, default, threads.
							io?: string

							// Attach a volume as a LUN to the vmi.
							lun?: {
								// Bus indicates the type of disk device to emulate.
								// supported values: virtio, sata, scsi.
								bus?: string

								// ReadOnly.
								// Defaults to false.
								readonly?: bool

								// Reservation indicates if the disk needs to support the
								// persistent reservation for the SCSI disk
								reservation?: bool
							}

							// Name is the device name
							name: string

							// Serial provides the ability to specify a serial number for the
							// disk device.
							serial?: string

							// If specified the disk is made sharable and multiple write from
							// different VMs are permitted
							shareable?: bool

							// If specified, disk address and its tag will be provided to the
							// guest via config drive metadata
							tag?: string
						}

						// When present, indicates that modifications should not be
						// persisted. An invalid or unrecognized dryRun directive will
						// result in an error response and no further processing of the
						// request. Valid values are:
						// - All: all dry run stages will be processed
						dryRun?: [...string]

						// Name represents the name that will be used to map the
						// disk to the corresponding volume. This overrides any name
						// set inside the Disk struct itself.
						name: string

						// VolumeSource represents the source of the volume to map to the
						// disk.
						volumeSource: {
							// DataVolume represents the dynamic creation a PVC for this
							// volume as well as
							// the process of populating that PVC with a disk image.
							dataVolume?: {
								// Hotpluggable indicates whether the volume can be hotplugged and
								// hotunplugged.
								hotpluggable?: bool

								// Name of both the DataVolume and the PVC in the same namespace.
								// After PVC population the DataVolume is garbage collected by
								// default.
								name: string
							}

							// PersistentVolumeClaimVolumeSource represents a reference to a
							// PersistentVolumeClaim in the same namespace.
							// Directly attached to the vmi via qemu.
							// More info:
							// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
							persistentVolumeClaim?: {
								// claimName is the name of a PersistentVolumeClaim in the same
								// namespace as the pod using this volume.
								// More info:
								// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
								claimName: string

								// Hotpluggable indicates whether the volume can be hotplugged and
								// hotunplugged.
								hotpluggable?: bool

								// readOnly Will force the ReadOnly setting in VolumeMounts.
								// Default false.
								readOnly?: bool
							}
						}
					}

					// RemoveVolumeOptions when set indicates a volume should be
					// removed. The details
					// within this field specify how to add the volume
					removeVolumeOptions?: {
						// When present, indicates that modifications should not be
						// persisted. An invalid or unrecognized dryRun directive will
						// result in an error response and no further processing of the
						// request. Valid values are:
						// - All: all dry run stages will be processed
						dryRun?: [...string]

						// Name represents the name that maps to both the disk and volume
						// that
						// should be removed
						name: string
					}
				}]

				// VolumeSnapshotStatuses indicates a list of statuses whether
				// snapshotting is
				// supported by each volume.
				volumeSnapshotStatuses?: [...{
					// True if the volume supports snapshotting
					enabled: bool

					// Volume name
					name: string

					// Empty if snapshotting is enabled, contains reason otherwise
					reason?: string
				}]
			}
		}
	}
	virtualMachineSnapshotName?: string
	volumeBackups?: [...{
		persistentVolumeClaim: {
			// Standard object's metadata.
			// More info:
			// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			metadata?: {}

			// Spec defines the desired characteristics of a volume requested
			// by a pod author.
			// More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
			spec?: {
				// accessModes contains the desired access modes the volume should
				// have.
				// More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
				accessModes?: [...string]

				// dataSource field can be used to specify either:
				// * An existing VolumeSnapshot object
				// (snapshot.storage.k8s.io/VolumeSnapshot)
				// * An existing PVC (PersistentVolumeClaim)
				// If the provisioner or an external controller can support the
				// specified data source,
				// it will create a new volume based on the contents of the
				// specified data source.
				// When the AnyVolumeDataSource feature gate is enabled,
				// dataSource contents will be copied to dataSourceRef,
				// and dataSourceRef contents will be copied to dataSource when
				// dataSourceRef.namespace is not specified.
				// If the namespace is specified, then dataSourceRef will not be
				// copied to dataSource.
				dataSource?: {
					// APIGroup is the group for the resource being referenced.
					// If APIGroup is not specified, the specified Kind must be in the
					// core API group.
					// For any other third-party types, APIGroup is required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string
				}

				// dataSourceRef specifies the object from which to populate the
				// volume with data, if a non-empty
				// volume is desired. This may be any object from a non-empty API
				// group (non
				// core object) or a PersistentVolumeClaim object.
				// When this field is specified, volume binding will only succeed
				// if the type of
				// the specified object matches some installed volume populator or
				// dynamic
				// provisioner.
				// This field will replace the functionality of the dataSource
				// field and as such
				// if both fields are non-empty, they must have the same value.
				// For backwards
				// compatibility, when namespace isn't specified in dataSourceRef,
				// both fields (dataSource and dataSourceRef) will be set to the
				// same
				// value automatically if one of them is empty and the other is
				// non-empty.
				// When namespace is specified in dataSourceRef,
				// dataSource isn't set to the same value and must be empty.
				// There are three important differences between dataSource and
				// dataSourceRef:
				// * While dataSource only allows two specific types of objects,
				// dataSourceRef
				// allows any non-core object, as well as PersistentVolumeClaim
				// objects.
				// * While dataSource ignores disallowed values (dropping them),
				// dataSourceRef
				// preserves all values, and generates an error if a disallowed
				// value is
				// specified.
				// * While dataSource only allows local objects, dataSourceRef
				// allows objects
				// in any namespaces.
				// (Beta) Using this field requires the AnyVolumeDataSource
				// feature gate to be enabled.
				// (Alpha) Using the namespace field of dataSourceRef requires the
				// CrossNamespaceVolumeDataSource feature gate to be enabled.
				dataSourceRef?: {
					// APIGroup is the group for the resource being referenced.
					// If APIGroup is not specified, the specified Kind must be in the
					// core API group.
					// For any other third-party types, APIGroup is required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string

					// Namespace is the namespace of resource being referenced
					// Note that when a namespace is specified, a
					// gateway.networking.k8s.io/ReferenceGrant object is required in
					// the referent namespace to allow that namespace's owner to
					// accept the reference. See the ReferenceGrant documentation for
					// details.
					// (Alpha) This field requires the CrossNamespaceVolumeDataSource
					// feature gate to be enabled.
					namespace?: string
				}

				// resources represents the minimum resources the volume should
				// have.
				// If RecoverVolumeExpansionFailure feature is enabled users are
				// allowed to specify resource requirements
				// that are lower than previous value but must still be higher
				// than capacity recorded in the
				// status field of the claim.
				// More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed.
					// More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required.
					// If Requests is omitted for a container, it defaults to Limits
					// if that is explicitly specified,
					// otherwise to an implementation-defined value. Requests cannot
					// exceed Limits.
					// More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// selector is a label query over volumes to consider for binding.
				selector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn,
						// the values array must be non-empty. If the operator is Exists
						// or DoesNotExist,
						// the values array must be empty. This array is replaced during a
						// strategic
						// merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels
					// map is equivalent to an element of matchExpressions, whose key
					// field is "key", the
					// operator is "In", and the values array contains only "value".
					// The requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// storageClassName is the name of the StorageClass required by
				// the claim.
				// More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
				storageClassName?: string

				// volumeAttributesClassName may be used to set the
				// VolumeAttributesClass used by this claim.
				// If specified, the CSI driver will create or update the volume
				// with the attributes defined
				// in the corresponding VolumeAttributesClass. This has a
				// different purpose than storageClassName,
				// it can be changed after the claim is created. An empty string
				// value means that no VolumeAttributesClass
				// will be applied to the claim but it's not allowed to reset this
				// field to empty string once it is set.
				// If unspecified and the PersistentVolumeClaim is unbound, the
				// default VolumeAttributesClass
				// will be set by the persistentvolume controller if it exists.
				// If the resource referred to by volumeAttributesClass does not
				// exist, this PersistentVolumeClaim will be
				// set to a Pending state, as reflected by the modifyVolumeStatus
				// field, until such as a resource
				// exists.
				// More info:
				// https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
				// (Alpha) Using this field requires the VolumeAttributesClass
				// feature gate to be enabled.
				volumeAttributesClassName?: string

				// volumeMode defines what type of volume is required by the
				// claim.
				// Value of Filesystem is implied when not included in claim spec.
				volumeMode?: string

				// volumeName is the binding reference to the PersistentVolume
				// backing this claim.
				volumeName?: string
			}
		}
		volumeName:          string
		volumeSnapshotName?: string
	}]
}
